/********************************************
 * Type specific TypeSupport source file.   *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/
#include <dds/dds.hpp>
#include "robobrawl.hh"


/******************************************************************
 *  ClockInfo TypeSupport Ops 
 ******************************************************************/
static const char* 
ClockInfoTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ClockInfo";
}

/******************************************************************/
static DDS_TypeSupport
ClockInfoTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ClockInfoTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ClockInfo TypeSupport::has_key
 ******************************************************************/
static unsigned char
ClockInfoTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ClockInfo TypeSupport_alloc
 ******************************************************************/
static void*
ClockInfoTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ClockInfo();
}

/******************************************************************
 *  ClockInfo TypeSupport_clear
 ******************************************************************/
static void
ClockInfoTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ClockInfo*>(instance)) -> clear();
}

/******************************************************************
 *  ClockInfo TypeSupport_destroy
 ******************************************************************/
static void
ClockInfoTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ClockInfo *>(instance));
}
/******************************************************************
 *  ClockInfo TypeSupport_copy
 ******************************************************************/
static int
ClockInfoTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ClockInfo *>(copy_to)) -> copy( static_cast<const ClockInfo *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ClockInfo TypeSupport_get_field
 ******************************************************************/
static unsigned char
ClockInfoTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ClockInfo::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ClockInfo TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ClockInfoTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ClockInfo TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ClockInfoTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ClockInfo TypeSupport_marshal
 ******************************************************************/
static int 
ClockInfoTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ClockInfo * data = static_cast<const ClockInfo*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ClockInfo TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ClockInfoTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ClockInfo TypeSupport_unmarshal
 ******************************************************************/
static int
ClockInfoTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ClockInfo * t = new(inst) ClockInfo;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ClockInfo); /*  */
}

/******************************************************************
 *  ClockInfo TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ClockInfoTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ClockInfoTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[468] = { 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x1c, 0x01, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1c, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x49, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x68, 0x61, 0x73, 0x47, 
    0x65, 0x61, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1c, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 468+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 468);
    }
  if (buf_len) *buf_len = 468+4;
  CDX_UNUSED(ts);
}
static void
ClockInfoTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 0x97, 0x7a, 0x01, 0x9d, 0x88  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ClockInfoTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0xa9, 0x8f, 0x7e, 0xea, 0xab, 0x6c, 0x20, 0x86, 0xad, 0x01, 0xeb, 
    0x93, 0xac, 0x45, 0x00, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 0x97, 0x7a, 
    0x01, 0x9d, 0x88, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
ClockInfoTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int * buf_len ) {
  if ( buf_len == NULL ) return;
  ClockInfo::gen_typeobj_v2( buf, buf_len );
}
 //  ClockInfo
static int
ClockInfoTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  ButtonInfo TypeSupport Ops 
 ******************************************************************/
static const char* 
ButtonInfoTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ButtonInfo";
}

/******************************************************************/
static DDS_TypeSupport
ButtonInfoTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ButtonInfoTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ButtonInfo TypeSupport::has_key
 ******************************************************************/
static unsigned char
ButtonInfoTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ButtonInfo TypeSupport_alloc
 ******************************************************************/
static void*
ButtonInfoTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ButtonInfo();
}

/******************************************************************
 *  ButtonInfo TypeSupport_clear
 ******************************************************************/
static void
ButtonInfoTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ButtonInfo*>(instance)) -> clear();
}

/******************************************************************
 *  ButtonInfo TypeSupport_destroy
 ******************************************************************/
static void
ButtonInfoTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ButtonInfo *>(instance));
}
/******************************************************************
 *  ButtonInfo TypeSupport_copy
 ******************************************************************/
static int
ButtonInfoTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ButtonInfo *>(copy_to)) -> copy( static_cast<const ButtonInfo *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ButtonInfo TypeSupport_get_field
 ******************************************************************/
static unsigned char
ButtonInfoTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ButtonInfo::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ButtonInfo TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ButtonInfoTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ButtonInfo TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ButtonInfoTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ButtonInfo TypeSupport_marshal
 ******************************************************************/
static int 
ButtonInfoTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ButtonInfo * data = static_cast<const ButtonInfo*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ButtonInfo TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ButtonInfoTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ButtonInfo TypeSupport_unmarshal
 ******************************************************************/
static int
ButtonInfoTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ButtonInfo * t = new(inst) ButtonInfo;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ButtonInfo); /*  */
}

/******************************************************************
 *  ButtonInfo TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ButtonInfoTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ButtonInfoTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[408] = { 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xdd, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0xe0, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x11, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xdd, 0x49, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x11, 0x4a, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 408+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 408);
    }
  if (buf_len) *buf_len = 408+4;
  CDX_UNUSED(ts);
}
static void
ButtonInfoTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 0x19, 0xf0, 0x89  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ButtonInfoTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x97, 0x73, 0xb6, 0x31, 0xad, 0xea, 0x74, 0x33, 0x31, 0xb4, 0x59, 
    0x8a, 0x96, 0x78, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 
    0x19, 0xf0, 0x89, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
ButtonInfoTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int * buf_len ) {
  if ( buf_len == NULL ) return;
  ButtonInfo::gen_typeobj_v2( buf, buf_len );
}
 //  ButtonInfo
static int
ButtonInfoTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  DeviceInfo TypeSupport Ops 
 ******************************************************************/
static const char* 
DeviceInfoTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "DeviceInfo";
}

/******************************************************************/
static DDS_TypeSupport
DeviceInfoTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
DeviceInfoTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  DeviceInfo TypeSupport::has_key
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 1;
}
/******************************************************************
 *  DeviceInfo TypeSupport_alloc
 ******************************************************************/
static void*
DeviceInfoTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new DeviceInfo();
}

/******************************************************************
 *  DeviceInfo TypeSupport_clear
 ******************************************************************/
static void
DeviceInfoTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<DeviceInfo*>(instance)) -> clear();
}

/******************************************************************
 *  DeviceInfo TypeSupport_destroy
 ******************************************************************/
static void
DeviceInfoTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<DeviceInfo *>(instance));
}
/******************************************************************
 *  DeviceInfo TypeSupport_copy
 ******************************************************************/
static int
DeviceInfoTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<DeviceInfo *>(copy_to)) -> copy( static_cast<const DeviceInfo *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  DeviceInfo TypeSupport_get_field
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return DeviceInfo::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  DeviceInfo TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
DeviceInfoTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  DeviceInfo TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  DeviceInfo TypeSupport_marshal
 ******************************************************************/
static int 
DeviceInfoTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const DeviceInfo * data = static_cast<const DeviceInfo*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  DeviceInfo TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
DeviceInfoTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/,
                             const void * inst,
                             unsigned char * buf,
                             int in_offset,
                             int buf_len )
{
  const DeviceInfo * t = (const DeviceInfo*)inst;
  int offset = in_offset;
  CDX_Xcdr2Encoder_t xcdr;
  CDX_XcdrEncoder_t * cdr = (CDX_XcdrEncoder_t*)&xcdr.base;
  CDX_Xcdr2Encoder_init( &xcdr, 0x00 /* bigendian*/, buf, buf_len );
  offset = t->marshal_key_hash( cdr );

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  DeviceInfo TypeSupport_unmarshal
 ******************************************************************/
static int
DeviceInfoTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  DeviceInfo * t = new(inst) DeviceInfo;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(DeviceInfo); /*  */
}

/******************************************************************
 *  DeviceInfo TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
DeviceInfoTypeSupport_unmarshal_key_hash( struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len)
{
  CDX_Xcdr2Decoder_t xcdr;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr.base;
  CDX_Xcdr2Decoder_init( &xcdr, 0x00 /* bigendian*/, buf, buf_len );
  xcdr.xcdr_buffer->maxalign = 4;
  DeviceInfo * t = (DeviceInfo *)inst;
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  CDX_UNUSED(buf_len);
  offset = t->unmarshal_key_hash( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(DeviceInfo); /*  */
}

static void
DeviceInfoTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[1820] = { 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x06, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x19, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1d, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf2, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xfb, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x1c, 0x01, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1c, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x49, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x68, 0x61, 0x73, 0x47, 
    0x65, 0x61, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xdd, 0x49, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x11, 0x4a, 0xbf, 
    0xa7, 0x01, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x49, 0x6e, 
    0x66, 0x6f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0xdd, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 
    0x63, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x70, 0xf5, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 
    0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x65, 0x00, 0x00, 0x00, 0xac, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x19, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xf0, 0x1d, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x72, 0x6f, 0x6c, 0x65, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x70, 0xf2, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xfb, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0x1c, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x63, 0x6c, 0x6f, 0x63, 
    0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x11, 0x4a, 0xbf, 0xa7, 0x01, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 
    0x01, 0x3f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x3f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0xf5, 0x49, 0xbf, 0xa7, 0x01, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 1820+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 1820);
    }
  if (buf_len) *buf_len = 1820+4;
  CDX_UNUSED(ts);
}
static void
DeviceInfoTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x99, 0x4d, 0x16, 0xd3, 0xe9, 0x5f, 0xce, 0x5a, 0x61, 0x84, 0x9b, 0x62, 0xa5, 0x4b  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
DeviceInfoTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int * buf_len ) {
  static unsigned char data[196] = { 
    0xc0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0xec, 0x7f, 0x5e, 0x48, 0xb3, 0xbf, 0x2a, 0x34, 0x9b, 0x84, 0x01, 
    0x84, 0xd0, 0x42, 0x00, 0x95, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0xa9, 0x8f, 0x7e, 0xea, 0xab, 0x6c, 0x20, 
    0x86, 0xad, 0x01, 0xeb, 0x93, 0xac, 0x45, 0x00, 0x47, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf1, 0x97, 0x73, 0xb6, 0x31, 0xad, 0xea, 0x74, 0x33, 0x31, 0xb4, 0x59, 0x8a, 0x96, 0x78, 0x00, 
    0x37, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0x99, 0x4d, 0x16, 0xd3, 0xe9, 0x5f, 0xce, 0x5a, 0x61, 0x84, 0x9b, 
    0x62, 0xa5, 0x4b, 0x00, 0xf1, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 
    0xa6, 0x05, 0x97, 0x7a, 0x01, 0x9d, 0x88, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 0x19, 0xf0, 0x89, 0x00, 
    0x5c, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 196+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 196);
    }
  if (buf_len) *buf_len = 196+4;
}
static void
DeviceInfoTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int * buf_len ) {
  if ( buf_len == NULL ) return;
  DeviceInfo::gen_typeobj_v2( buf, buf_len );
}
 //  DeviceInfo
static int
DeviceInfoTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


struct _TypeSupport org::toc::coredx::topic::TypeTraits<ClockInfo>::_ts = 
  {
    ClockInfoTypeSupport_get_fully_qualified_type_name,
    ClockInfoTypeSupport_clone_ts,
    ClockInfoTypeSupport_delete_ts,
    ClockInfoTypeSupport_has_key,
    ClockInfoTypeSupport_key_must_hash,
    ClockInfoTypeSupport_marshal_fixed_size,
    ClockInfoTypeSupport_marshal_cdr,
    ClockInfoTypeSupport_marshal_key_hash,
    ClockInfoTypeSupport_unmarshal_cdr,
    ClockInfoTypeSupport_unmarshal_key_hash,
    ClockInfoTypeSupport_alloc,
    ClockInfoTypeSupport_clear,
    ClockInfoTypeSupport_destroy,
    ClockInfoTypeSupport_copy,
    ClockInfoTypeSupport_get_field,
    ClockInfoTypeSupport_gen_typeobj,
    ClockInfoTypeSupport_gen_typeid_v2,
    ClockInfoTypeSupport_gen_typeinfo_v2,
    ClockInfoTypeSupport_gen_typeobj_v2,
    ClockInfoTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<ButtonInfo>::_ts = 
  {
    ButtonInfoTypeSupport_get_fully_qualified_type_name,
    ButtonInfoTypeSupport_clone_ts,
    ButtonInfoTypeSupport_delete_ts,
    ButtonInfoTypeSupport_has_key,
    ButtonInfoTypeSupport_key_must_hash,
    ButtonInfoTypeSupport_marshal_fixed_size,
    ButtonInfoTypeSupport_marshal_cdr,
    ButtonInfoTypeSupport_marshal_key_hash,
    ButtonInfoTypeSupport_unmarshal_cdr,
    ButtonInfoTypeSupport_unmarshal_key_hash,
    ButtonInfoTypeSupport_alloc,
    ButtonInfoTypeSupport_clear,
    ButtonInfoTypeSupport_destroy,
    ButtonInfoTypeSupport_copy,
    ButtonInfoTypeSupport_get_field,
    ButtonInfoTypeSupport_gen_typeobj,
    ButtonInfoTypeSupport_gen_typeid_v2,
    ButtonInfoTypeSupport_gen_typeinfo_v2,
    ButtonInfoTypeSupport_gen_typeobj_v2,
    ButtonInfoTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<DeviceInfo>::_ts = 
  {
    DeviceInfoTypeSupport_get_fully_qualified_type_name,
    DeviceInfoTypeSupport_clone_ts,
    DeviceInfoTypeSupport_delete_ts,
    DeviceInfoTypeSupport_has_key,
    DeviceInfoTypeSupport_key_must_hash,
    DeviceInfoTypeSupport_marshal_fixed_size,
    DeviceInfoTypeSupport_marshal_cdr,
    DeviceInfoTypeSupport_marshal_key_hash,
    DeviceInfoTypeSupport_unmarshal_cdr,
    DeviceInfoTypeSupport_unmarshal_key_hash,
    DeviceInfoTypeSupport_alloc,
    DeviceInfoTypeSupport_clear,
    DeviceInfoTypeSupport_destroy,
    DeviceInfoTypeSupport_copy,
    DeviceInfoTypeSupport_get_field,
    DeviceInfoTypeSupport_gen_typeobj,
    DeviceInfoTypeSupport_gen_typeid_v2,
    DeviceInfoTypeSupport_gen_typeinfo_v2,
    DeviceInfoTypeSupport_gen_typeobj_v2,
    DeviceInfoTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
