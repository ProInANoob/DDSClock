/********************************************
 * Type specific TypeSupport source file.   *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/
#include <dds/dds.hpp>
#include "robobrawl.hh"


/******************************************************************
 *  Heartbeat TypeSupport Ops 
 ******************************************************************/
static const char* 
HeartbeatTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "Heartbeat";
}

/******************************************************************/
static DDS_TypeSupport
HeartbeatTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
HeartbeatTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  Heartbeat TypeSupport::has_key
 ******************************************************************/
static unsigned char
HeartbeatTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  Heartbeat TypeSupport_alloc
 ******************************************************************/
static void*
HeartbeatTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new Heartbeat();
}

/******************************************************************
 *  Heartbeat TypeSupport_clear
 ******************************************************************/
static void
HeartbeatTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<Heartbeat*>(instance)) -> clear();
}

/******************************************************************
 *  Heartbeat TypeSupport_destroy
 ******************************************************************/
static void
HeartbeatTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<Heartbeat *>(instance));
}
/******************************************************************
 *  Heartbeat TypeSupport_copy
 ******************************************************************/
static int
HeartbeatTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<Heartbeat *>(copy_to)) -> copy( static_cast<const Heartbeat *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  Heartbeat TypeSupport_get_field
 ******************************************************************/
static unsigned char
HeartbeatTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return Heartbeat::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  Heartbeat TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
HeartbeatTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  Heartbeat TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
HeartbeatTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  Heartbeat TypeSupport_marshal
 ******************************************************************/
static int 
HeartbeatTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const Heartbeat * data = static_cast<const Heartbeat*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  Heartbeat TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
HeartbeatTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  Heartbeat TypeSupport_unmarshal
 ******************************************************************/
static int
HeartbeatTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  Heartbeat * t = new(inst) Heartbeat;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(Heartbeat); /*  */
}

/******************************************************************
 *  Heartbeat TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
HeartbeatTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
HeartbeatTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[416] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x23, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0xe8, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x21, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x48, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x23, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 
    0x0f, 0x00, 0x00, 0x00, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x4e, 0x75, 0x6d, 0x62, 
    0x65, 0x72, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x50, 0x21, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 416+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 416);
    }
  if (buf_len) *buf_len = 416+4;
  CDX_UNUSED(ts);
}
static void
HeartbeatTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0xf5, 0x6e, 0x21, 0x1b, 0x84, 0x28, 0x00, 0xa0, 0x94, 0x8d, 0x08, 0x04, 0x2a, 0x3b  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
HeartbeatTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0xc6, 0xd3, 0x37, 0x44, 0x58, 0x31, 0xb2, 0x0a, 0x72, 0x6a, 0x3b, 
    0x3b, 0xf6, 0x16, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0xf5, 0x6e, 0x21, 0x1b, 0x84, 0x28, 0x00, 0xa0, 0x94, 0x8d, 0x08, 
    0x04, 0x2a, 0x3b, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
HeartbeatTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  Heartbeat::gen_typeobj_v2( buf, buf_len );
}
 //  Heartbeat
static int
HeartbeatTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  SysName TypeSupport Ops 
 ******************************************************************/
static const char* 
SysNameTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "SysName";
}

/******************************************************************/
static DDS_TypeSupport
SysNameTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
SysNameTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  SysName TypeSupport::has_key
 ******************************************************************/
static unsigned char
SysNameTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  SysName TypeSupport_alloc
 ******************************************************************/
static void*
SysNameTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new SysName();
}

/******************************************************************
 *  SysName TypeSupport_clear
 ******************************************************************/
static void
SysNameTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<SysName*>(instance)) -> clear();
}

/******************************************************************
 *  SysName TypeSupport_destroy
 ******************************************************************/
static void
SysNameTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<SysName *>(instance));
}
/******************************************************************
 *  SysName TypeSupport_copy
 ******************************************************************/
static int
SysNameTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<SysName *>(copy_to)) -> copy( static_cast<const SysName *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  SysName TypeSupport_get_field
 ******************************************************************/
static unsigned char
SysNameTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return SysName::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  SysName TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
SysNameTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  SysName TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
SysNameTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  SysName TypeSupport_marshal
 ******************************************************************/
static int 
SysNameTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const SysName * data = static_cast<const SysName*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  SysName TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
SysNameTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  SysName TypeSupport_unmarshal
 ******************************************************************/
static int
SysNameTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  SysName * t = new(inst) SysName;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(SysName); /*  */
}

/******************************************************************
 *  SysName TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
SysNameTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
SysNameTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[528] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x2c, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x30, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0xe8, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x2b, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x53, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x65, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x2c, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xf0, 0x30, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 
    0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x30, 0x2b, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 528+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 528);
    }
  if (buf_len) *buf_len = 528+4;
  CDX_UNUSED(ts);
}
static void
SysNameTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0xe0, 0xeb, 0xc1, 0xa8, 0xe3, 0x3f, 0x07, 0xb6, 0x69, 0x6c, 0xae, 0xea, 0xd4, 0xca  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
SysNameTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x22, 0x17, 0xbc, 0xd3, 0x8d, 0x15, 0xa4, 0x7d, 0xd9, 0x04, 0x13, 
    0x9f, 0x51, 0xd4, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0xe0, 0xeb, 0xc1, 0xa8, 0xe3, 0x3f, 0x07, 0xb6, 0x69, 0x6c, 0xae, 
    0xea, 0xd4, 0xca, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
SysNameTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  SysName::gen_typeobj_v2( buf, buf_len );
}
 //  SysName
static int
SysNameTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  timeValue TypeSupport Ops 
 ******************************************************************/
static const char* 
timeValueTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "timeValue";
}

/******************************************************************/
static DDS_TypeSupport
timeValueTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
timeValueTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  timeValue TypeSupport::has_key
 ******************************************************************/
static unsigned char
timeValueTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  timeValue TypeSupport_alloc
 ******************************************************************/
static void*
timeValueTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new timeValue();
}

/******************************************************************
 *  timeValue TypeSupport_clear
 ******************************************************************/
static void
timeValueTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<timeValue*>(instance)) -> clear();
}

/******************************************************************
 *  timeValue TypeSupport_destroy
 ******************************************************************/
static void
timeValueTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<timeValue *>(instance));
}
/******************************************************************
 *  timeValue TypeSupport_copy
 ******************************************************************/
static int
timeValueTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<timeValue *>(copy_to)) -> copy( static_cast<const timeValue *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  timeValue TypeSupport_get_field
 ******************************************************************/
static unsigned char
timeValueTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return timeValue::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  timeValue TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
timeValueTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 12;
  else
    return 16;
}

/******************************************************************
 *  timeValue TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
timeValueTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 0; }

/******************************************************************
 *  timeValue TypeSupport_marshal
 ******************************************************************/
static int 
timeValueTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const timeValue * data = static_cast<const timeValue*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  timeValue TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
timeValueTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  timeValue TypeSupport_unmarshal
 ******************************************************************/
static int
timeValueTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  timeValue * t = new(inst) timeValue;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(timeValue); /*  */
}

/******************************************************************
 *  timeValue TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
timeValueTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
timeValueTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[280] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0xd0, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x6f, 
    0x6e, 0x64, 0x73, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 280+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 280);
    }
  if (buf_len) *buf_len = 280+4;
  CDX_UNUSED(ts);
}
static void
timeValueTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
timeValueTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x9e, 0xc4, 0x47, 0x25, 0x7a, 0xe1, 0x1e, 0x3d, 0xf7, 0x9a, 0x68, 
    0xe1, 0x2f, 0xc6, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 0xbe, 0x77, 0xfb, 0x8c, 
    0xc6, 0xf4, 0x89, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
timeValueTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  timeValue::gen_typeobj_v2( buf, buf_len );
}
 //  timeValue
static int
timeValueTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  ClockCommand TypeSupport Ops 
 ******************************************************************/
static const char* 
ClockCommandTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ClockCommand";
}

/******************************************************************/
static DDS_TypeSupport
ClockCommandTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ClockCommandTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ClockCommand TypeSupport::has_key
 ******************************************************************/
static unsigned char
ClockCommandTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ClockCommand TypeSupport_alloc
 ******************************************************************/
static void*
ClockCommandTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ClockCommand();
}

/******************************************************************
 *  ClockCommand TypeSupport_clear
 ******************************************************************/
static void
ClockCommandTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ClockCommand*>(instance)) -> clear();
}

/******************************************************************
 *  ClockCommand TypeSupport_destroy
 ******************************************************************/
static void
ClockCommandTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ClockCommand *>(instance));
}
/******************************************************************
 *  ClockCommand TypeSupport_copy
 ******************************************************************/
static int
ClockCommandTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ClockCommand *>(copy_to)) -> copy( static_cast<const ClockCommand *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ClockCommand TypeSupport_get_field
 ******************************************************************/
static unsigned char
ClockCommandTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ClockCommand::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ClockCommand TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ClockCommandTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ClockCommand TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ClockCommandTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ClockCommand TypeSupport_marshal
 ******************************************************************/
static int 
ClockCommandTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ClockCommand * data = static_cast<const ClockCommand*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ClockCommand TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ClockCommandTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ClockCommand TypeSupport_unmarshal
 ******************************************************************/
static int
ClockCommandTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ClockCommand * t = new(inst) ClockCommand;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ClockCommand); /*  */
}

/******************************************************************
 *  ClockCommand TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ClockCommandTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ClockCommandTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[1232] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x40, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0xd0, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x6f, 
    0x6e, 0x64, 0x73, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 
    0x72, 0x73, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x65, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x47, 0x52, 0x45, 0x45, 0x4e, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x4f, 0x52, 
    0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 0x55, 0x45, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x52, 0x45, 0x44, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 0x41, 0x43, 0x4b, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0x44, 0x02, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3e, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x43, 0x6f, 0x6d, 
    0x6d, 0x61, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 
    0xe4, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xb0, 0x40, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x69, 0x73, 0x4f, 0x66, 0x66, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x64, 0x6f, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x10, 0x35, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
    0x6d, 0x61, 0x69, 0x6e, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x62, 0x6c, 0x75, 0x65, 0x47, 0x65, 0x61, 0x72, 
    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x47, 0x65, 0x61, 0x72, 0x43, 0x6f, 
    0x6c, 0x6f, 0x72, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3e, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 1232+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 1232);
    }
  if (buf_len) *buf_len = 1232+4;
  CDX_UNUSED(ts);
}
static void
ClockCommandTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x20, 0xdc, 0x8b, 0x0c, 0x06, 0x16, 0x3b, 0x3a, 0xc0, 0x97, 0xfa, 0x11, 0x97, 0x71  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ClockCommandTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[196] = { 
    0xc0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0xcb, 0xcf, 0x44, 0xa7, 0x70, 0x07, 0x51, 0xfe, 0x71, 0x43, 0xde, 
    0xfb, 0xaa, 0x11, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x9e, 0xc4, 0x47, 0x25, 0x7a, 0xe1, 0x1e, 
    0x3d, 0xf7, 0x9a, 0x68, 0xe1, 0x2f, 0xc6, 0x00, 0x37, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf1, 0x1a, 0xbc, 0x79, 0x0c, 0x86, 0xa3, 0xc6, 0x93, 0xd2, 0x01, 0x77, 0x5f, 0x80, 0xda, 0x00, 
    0x8e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0x20, 0xdc, 0x8b, 0x0c, 0x06, 0x16, 0x3b, 0x3a, 0xc0, 0x97, 0xfa, 
    0x11, 0x97, 0x71, 0x00, 0x36, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 
    0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf2, 0xf2, 0xca, 0x62, 0xa2, 0x9c, 0x57, 0x59, 0x90, 0x7a, 0x74, 0x84, 0x89, 0xff, 0x92, 0x00, 
    0xf6, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 196+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 196);
    }
  if (buf_len) *buf_len = 196+4;
}
static void
ClockCommandTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  ClockCommand::gen_typeobj_v2( buf, buf_len );
}
 //  ClockCommand
static int
ClockCommandTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  ButtonCommand TypeSupport Ops 
 ******************************************************************/
static const char* 
ButtonCommandTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ButtonCommand";
}

/******************************************************************/
static DDS_TypeSupport
ButtonCommandTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ButtonCommandTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ButtonCommand TypeSupport::has_key
 ******************************************************************/
static unsigned char
ButtonCommandTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ButtonCommand TypeSupport_alloc
 ******************************************************************/
static void*
ButtonCommandTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ButtonCommand();
}

/******************************************************************
 *  ButtonCommand TypeSupport_clear
 ******************************************************************/
static void
ButtonCommandTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ButtonCommand*>(instance)) -> clear();
}

/******************************************************************
 *  ButtonCommand TypeSupport_destroy
 ******************************************************************/
static void
ButtonCommandTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ButtonCommand *>(instance));
}
/******************************************************************
 *  ButtonCommand TypeSupport_copy
 ******************************************************************/
static int
ButtonCommandTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ButtonCommand *>(copy_to)) -> copy( static_cast<const ButtonCommand *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ButtonCommand TypeSupport_get_field
 ******************************************************************/
static unsigned char
ButtonCommandTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ButtonCommand::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ButtonCommand TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ButtonCommandTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ButtonCommand TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ButtonCommandTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ButtonCommand TypeSupport_marshal
 ******************************************************************/
static int 
ButtonCommandTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ButtonCommand * data = static_cast<const ButtonCommand*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ButtonCommand TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ButtonCommandTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ButtonCommand TypeSupport_unmarshal
 ******************************************************************/
static int
ButtonCommandTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ButtonCommand * t = new(inst) ButtonCommand;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ButtonCommand); /*  */
}

/******************************************************************
 *  ButtonCommand TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ButtonCommandTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ButtonCommandTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[664] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x58, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0xd4, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x04, 0x00, 
    0x20, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x47, 0x52, 0x45, 0x45, 0x4e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x55, 0x45, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x52, 0x45, 0x44, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x41, 0x43, 0x4b, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xd0, 0x56, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x58, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x56, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 664+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 664);
    }
  if (buf_len) *buf_len = 664+4;
  CDX_UNUSED(ts);
}
static void
ButtonCommandTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x08, 0xbd, 0x40, 0x23, 0x0e, 0xd1, 0x2e, 0x18, 0x1c, 0xb3, 0x94, 0x22, 0xb1, 0x93  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ButtonCommandTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[148] = { 
    0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x93, 0xe3, 0x19, 0x76, 0x2f, 0xae, 0x19, 0x8b, 0x5c, 0x99, 0xb1, 
    0xba, 0x9a, 0x95, 0x00, 0x45, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x1a, 0xbc, 0x79, 0x0c, 0x86, 0xa3, 0xc6, 
    0x93, 0xd2, 0x01, 0x77, 0x5f, 0x80, 0xda, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 
    0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x08, 0xbd, 0x40, 
    0x23, 0x0e, 0xd1, 0x2e, 0x18, 0x1c, 0xb3, 0x94, 0x22, 0xb1, 0x93, 0x00, 0x76, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf2, 0xf2, 0xca, 0x62, 0xa2, 0x9c, 0x57, 0x59, 0x90, 0x7a, 0x74, 0x84, 0x89, 0xff, 0x92, 0x00, 
    0xf6, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 148+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 148);
    }
  if (buf_len) *buf_len = 148+4;
}
static void
ButtonCommandTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  ButtonCommand::gen_typeobj_v2( buf, buf_len );
}
 //  ButtonCommand
static int
ButtonCommandTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  ButtonData TypeSupport Ops 
 ******************************************************************/
static const char* 
ButtonDataTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ButtonData";
}

/******************************************************************/
static DDS_TypeSupport
ButtonDataTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ButtonDataTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ButtonData TypeSupport::has_key
 ******************************************************************/
static unsigned char
ButtonDataTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ButtonData TypeSupport_alloc
 ******************************************************************/
static void*
ButtonDataTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ButtonData();
}

/******************************************************************
 *  ButtonData TypeSupport_clear
 ******************************************************************/
static void
ButtonDataTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ButtonData*>(instance)) -> clear();
}

/******************************************************************
 *  ButtonData TypeSupport_destroy
 ******************************************************************/
static void
ButtonDataTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ButtonData *>(instance));
}
/******************************************************************
 *  ButtonData TypeSupport_copy
 ******************************************************************/
static int
ButtonDataTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ButtonData *>(copy_to)) -> copy( static_cast<const ButtonData *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ButtonData TypeSupport_get_field
 ******************************************************************/
static unsigned char
ButtonDataTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ButtonData::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ButtonData TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ButtonDataTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ButtonData TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ButtonDataTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ButtonData TypeSupport_marshal
 ******************************************************************/
static int 
ButtonDataTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ButtonData * data = static_cast<const ButtonData*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ButtonData TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ButtonDataTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ButtonData TypeSupport_unmarshal
 ******************************************************************/
static int
ButtonDataTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ButtonData * t = new(inst) ButtonData;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ButtonData); /*  */
}

/******************************************************************
 *  ButtonData TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ButtonDataTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ButtonDataTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[656] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x60, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x64, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x68, 0x01, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x5f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x60, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x64, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x73, 
    0x73, 0x65, 0x64, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x74, 0x61, 0x70, 0x6f, 0x75, 0x74, 0x50, 0x72, 0x65, 0x73, 0x73, 0x65, 
    0x64, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x30, 0x5f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 656+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 656);
    }
  if (buf_len) *buf_len = 656+4;
  CDX_UNUSED(ts);
}
static void
ButtonDataTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x06, 0x21, 0x88, 0x34, 0x3c, 0x9f, 0x1f, 0x36, 0x73, 0x3b, 0x2b, 0x58, 0xb0, 0x18  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ButtonDataTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[100] = { 
    0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x3b, 0xa1, 0x60, 0x28, 0x86, 0xc6, 0x84, 0x7f, 0xc2, 0x21, 0xbc, 
    0xf1, 0x18, 0x9a, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf2, 0x06, 0x21, 0x88, 0x34, 0x3c, 0x9f, 0x1f, 0x36, 0x73, 0x3b, 0x2b, 
    0x58, 0xb0, 0x18, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 100+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 100);
    }
  if (buf_len) *buf_len = 100+4;
}
static void
ButtonDataTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  ButtonData::gen_typeobj_v2( buf, buf_len );
}
 //  ButtonData
static int
ButtonDataTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  ArenaData TypeSupport Ops 
 ******************************************************************/
static const char* 
ArenaDataTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "ArenaData";
}

/******************************************************************/
static DDS_TypeSupport
ArenaDataTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
ArenaDataTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  ArenaData TypeSupport::has_key
 ******************************************************************/
static unsigned char
ArenaDataTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 0;
}
/******************************************************************
 *  ArenaData TypeSupport_alloc
 ******************************************************************/
static void*
ArenaDataTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new ArenaData();
}

/******************************************************************
 *  ArenaData TypeSupport_clear
 ******************************************************************/
static void
ArenaDataTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<ArenaData*>(instance)) -> clear();
}

/******************************************************************
 *  ArenaData TypeSupport_destroy
 ******************************************************************/
static void
ArenaDataTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<ArenaData *>(instance));
}
/******************************************************************
 *  ArenaData TypeSupport_copy
 ******************************************************************/
static int
ArenaDataTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<ArenaData *>(copy_to)) -> copy( static_cast<const ArenaData *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  ArenaData TypeSupport_get_field
 ******************************************************************/
static unsigned char
ArenaDataTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return ArenaData::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  ArenaData TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
ArenaDataTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  ArenaData TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
ArenaDataTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  ArenaData TypeSupport_marshal
 ******************************************************************/
static int 
ArenaDataTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const ArenaData * data = static_cast<const ArenaData*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  ArenaData TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
ArenaDataTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/, 
                const void * /* inst*/, unsigned char * /*buf*/,
                int /*offset*/, int /*buf_len*/ )
{
  return 0; /* has no key */
}

/******************************************************************
 *  ArenaData TypeSupport_unmarshal
 ******************************************************************/
static int
ArenaDataTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  ArenaData * t = new(inst) ArenaData;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(ArenaData); /*  */
}

/******************************************************************
 *  ArenaData TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
ArenaDataTypeSupport_unmarshal_key_hash( struct _TypeSupport * /* ts */,
                       void          * /* inst */,
                       unsigned char * /* buf */,
                       int             /* offset */,
                       int             /* buf_len */)
{ return 0; /* no key */}
static void
ArenaDataTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[836] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x72, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x76, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0xd4, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x04, 0x00, 
    0x20, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x47, 0x52, 0x45, 0x45, 0x4e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x55, 0x45, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x52, 0x45, 0x44, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x41, 0x43, 0x4b, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x10, 0x71, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
    0x41, 0x72, 0x65, 0x6e, 0x61, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x65, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x72, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xd0, 0x76, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 
    0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x90, 0x1f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x71, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 836+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 836);
    }
  if (buf_len) *buf_len = 836+4;
  CDX_UNUSED(ts);
}
static void
ArenaDataTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0xfb, 0xf7, 0x81, 0x70, 0x81, 0x1e, 0xe3, 0x9e, 0x40, 0x80, 0x8d, 0xd0, 0xa6, 0x2b  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
ArenaDataTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[148] = { 
    0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0x22, 0xab, 0x16, 0x36, 0x96, 0x14, 0x87, 0xbb, 0x07, 0xe4, 0x4f, 
    0x11, 0x95, 0x95, 0x00, 0x55, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x1a, 0xbc, 0x79, 0x0c, 0x86, 0xa3, 0xc6, 
    0x93, 0xd2, 0x01, 0x77, 0x5f, 0x80, 0xda, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 
    0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xfb, 0xf7, 0x81, 
    0x70, 0x81, 0x1e, 0xe3, 0x9e, 0x40, 0x80, 0x8d, 0xd0, 0xa6, 0x2b, 0x00, 0x88, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf2, 0xf2, 0xca, 0x62, 0xa2, 0x9c, 0x57, 0x59, 0x90, 0x7a, 0x74, 0x84, 0x89, 0xff, 0x92, 0x00, 
    0xf6, 0x00, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 148+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 148);
    }
  if (buf_len) *buf_len = 148+4;
}
static void
ArenaDataTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  ArenaData::gen_typeobj_v2( buf, buf_len );
}
 //  ArenaData
static int
ArenaDataTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


/******************************************************************
 *  DeviceInfo TypeSupport Ops 
 ******************************************************************/
static const char* 
DeviceInfoTypeSupport_get_fully_qualified_type_name( struct _TypeSupport * /* ts */ )
{
  return "DeviceInfo";
}

/******************************************************************/
static DDS_TypeSupport
DeviceInfoTypeSupport_clone_ts( struct _TypeSupport * ts ) {
   DDS_TypeSupport retval = NULL;
   retval = static_cast<DDS_TypeSupport>(CoreDX_DDS_malloc(sizeof(*retval)));
   if (retval) memcpy(retval, ts, sizeof(*retval));
   return retval;
}

/******************************************************************/
static void
DeviceInfoTypeSupport_delete_ts( struct _TypeSupport * ts ) {
   CoreDX_DDS_free(ts);
}


/******************************************************************
 *  DeviceInfo TypeSupport::has_key
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_has_key(struct _TypeSupport * /*ts*/)
{
  return 1;
}
/******************************************************************
 *  DeviceInfo TypeSupport_alloc
 ******************************************************************/
static void*
DeviceInfoTypeSupport_alloc(struct _TypeSupport * /*ts*/)
{
  return new DeviceInfo();
}

/******************************************************************
 *  DeviceInfo TypeSupport_clear
 ******************************************************************/
static void
DeviceInfoTypeSupport_clear(struct _TypeSupport * /*ts*/, void * instance)
{
  if ( instance ) (static_cast<DeviceInfo*>(instance)) -> clear();
}

/******************************************************************
 *  DeviceInfo TypeSupport_destroy
 ******************************************************************/
static void
DeviceInfoTypeSupport_destroy(struct _TypeSupport * /*ts*/, void *instance)
{
  delete (static_cast<DeviceInfo *>(instance));
}
/******************************************************************
 *  DeviceInfo TypeSupport_copy
 ******************************************************************/
static int
DeviceInfoTypeSupport_copy(struct _TypeSupport * /*ts*/, void * copy_to, const void * copy_from)
{
   if ( copy_to ) return (static_cast<DeviceInfo *>(copy_to)) -> copy( static_cast<const DeviceInfo *>(copy_from) );
   else return -1;
}

/******************************************************************
 *  DeviceInfo TypeSupport_get_field
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_get_field( struct _TypeSupport * ts,
                  const char        * fieldname,
                  CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(ts);
  if (field_def) memset(field_def, 0, sizeof(*field_def));
  return DeviceInfo::get_field_def(fieldname, field_def);
}

/******************************************************************
 *  DeviceInfo TypeSupport_marshal_fixed_size
 ******************************************************************/
static int
DeviceInfoTypeSupport_marshal_fixed_size (  struct _TypeSupport * /*ts*/,
                  CDX_DataEncoding encoding )
{
  if ( encoding == XCDR_PLAIN_CDR1 )
    return 0;
  else
    return 0;
}

/******************************************************************
 *  DeviceInfo TypeSupport_key_must_hash
 ******************************************************************/
static unsigned char
DeviceInfoTypeSupport_key_must_hash  (  struct _TypeSupport * /*ts*/ )
{ return 1; }

/******************************************************************
 *  DeviceInfo TypeSupport_marshal
 ******************************************************************/
static int 
DeviceInfoTypeSupport_marshal_cdr ( struct _TypeSupport * ts, 
                       const void    * inst,
                       unsigned char * buf,
                       int    in_offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int offset = in_offset;
  const DeviceInfo * data = static_cast<const DeviceInfo*>(inst);
  CDX_XcdrEncoderStorage_t   xcdr;
  CDX_XcdrEncoder_t  * cdr = CDX_XCDR_ENCODER(&xcdr);
  CDX_XcdrEncoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  offset = data->marshal_cdr( cdr, just_keys);

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  DeviceInfo TypeSupport_marshal_key_hash
 ******************************************************************/
static int 
DeviceInfoTypeSupport_marshal_key_hash  (  struct _TypeSupport * /*ts*/,
                             const void * inst,
                             unsigned char * buf,
                             int in_offset,
                             int buf_len )
{
  const DeviceInfo * t = (const DeviceInfo*)inst;
  int offset = in_offset;
  CDX_Xcdr2Encoder_t xcdr;
  CDX_XcdrEncoder_t * cdr = (CDX_XcdrEncoder_t*)&xcdr.base;
  CDX_Xcdr2Encoder_init( &xcdr, 0x00 /* bigendian*/, buf, buf_len );
  offset = t->marshal_key_hash( cdr );

  CDX_XcdrEncoder_clear( cdr );
  return offset-in_offset;
}


/******************************************************************
 *  DeviceInfo TypeSupport_unmarshal
 ******************************************************************/
static int
DeviceInfoTypeSupport_unmarshal_cdr(struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len,
                       CDX_DataEncoding encoding,
                       unsigned char le,
                       int    just_keys)
{
  int           err;
  CDX_XcdrDecoderStorage_t   xcdr;
  CDX_XcdrDecoder_t  * cdr = CDX_XCDR_DECODER(&xcdr);
  CDX_XcdrDecoder_init( &xcdr, encoding, (le?0x01:0x00), buf, buf_len );
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  DeviceInfo * t = new(inst) DeviceInfo;
  err = t->unmarshal_cdr( cdr, just_keys );
  if ( err < 0 ) 
    return err;
  else
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(DeviceInfo); /*  */
}

/******************************************************************
 *  DeviceInfo TypeSupport_unmarshal_key_hash
 ******************************************************************/
static int
DeviceInfoTypeSupport_unmarshal_key_hash( struct _TypeSupport * ts,
                       void    * inst,
                       unsigned char * buf,
                       int    offset,
                       int    buf_len)
{
  CDX_Xcdr2Decoder_t xcdr;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr.base;
  CDX_Xcdr2Decoder_init( &xcdr, 0x00 /* bigendian*/, buf, buf_len );
  xcdr.xcdr_buffer->maxalign = 4;
  DeviceInfo * t = (DeviceInfo *)inst;
  CDX_UNUSED(ts);
  CDX_UNUSED(offset);
  CDX_UNUSED(buf_len);
  offset = t->unmarshal_key_hash( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return sizeof(DeviceInfo); /*  */
}

static void
DeviceInfoTypeSupport_gen_typeobj( struct _TypeSupport * ts,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[1040] = { 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x83, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0xe8, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x0f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x64, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 
    0x93, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 
    0x54, 0x52, 0x4f, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
    0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x42, 0x55, 0x54, 0x54, 0x4f, 0x4e, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 
    0x47, 0x45, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 
    0x5f, 0x42, 0x55, 0x54, 0x54, 0x4f, 0x4e, 0x5f, 0x42, 0x4c, 0x55, 0x45, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x43, 0x4c, 0x4f, 
    0x43, 0x4b, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 
    0x5f, 0x41, 0x52, 0x45, 0x4e, 0x41, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x8a, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x8e, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x00, 0x40, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x78, 0x01, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x7d, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x65, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x83, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x90, 0x0f, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x72, 0x6f, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x8a, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x8e, 0x8b, 0x2d, 
    0x97, 0x62, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 
    0x61, 0x6d, 0x65, 0x00, 0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00, 
    0x01, 0x7f, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x70, 0x7d, 0x8b, 0x2d, 0x97, 0x62, 0x00, 0x00, 0x02, 0x3f, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 1040+4))
    {
       buf[0] = 0;
       buf[1] = 1;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 1040);
    }
  if (buf_len) *buf_len = 1040+4;
  CDX_UNUSED(ts);
}
static void
DeviceInfoTypeSupport_gen_typeid_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[15] = { 
    0xf2, 0x4a, 0x6e, 0x18, 0xad, 0x6e, 0xf9, 0x6d, 0x6d, 0xf9, 0x99, 0xe8, 0xbf, 0xc6, 0xec  }; 
  if (buf && buf_len && (*buf_len >= 15+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 15);
    }
  if (buf_len) *buf_len = 15+4;
}
static void
DeviceInfoTypeSupport_gen_typeinfo_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf, int32_t * buf_len ) {
  static unsigned char data[148] = { 
    0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0xf1, 0xba, 0x17, 0x86, 0x0f, 0x85, 0x60, 0x1d, 0x16, 0x52, 0xa1, 0x6e, 
    0x21, 0x60, 0x2c, 0x00, 0x68, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x1a, 0xd1, 0x98, 0xb1, 0x20, 0xa3, 0x90, 
    0x93, 0x72, 0xb1, 0xa1, 0x70, 0x71, 0xc9, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 
    0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x4a, 0x6e, 0x18, 
    0xad, 0x6e, 0xf9, 0x6d, 0x6d, 0xf9, 0x99, 0xe8, 0xbf, 0xc6, 0xec, 0x00, 0xa6, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0xf2, 0xe1, 0xc7, 0xea, 0x82, 0x4f, 0x11, 0xcf, 0x36, 0x86, 0x65, 0xb9, 0xdb, 0x60, 0x40, 0x00, 
    0x09, 0x01, 0x00, 0x00  }; 
  if (buf && buf_len && (*buf_len >= 148+4))
    {
       buf[0] = 0x00;
       buf[1] = 0x07;
       buf[2] = 0;
       buf[3] = 0;
       memcpy(buf+4, data, 148);
    }
  if (buf_len) *buf_len = 148+4;
}
static void
DeviceInfoTypeSupport_gen_typeobj_v2( struct _TypeSupport * /* ts */,
                           unsigned char *buf,
                           int32_t * buf_len ) {
  if ( buf_len == NULL ) return;
  DeviceInfo::gen_typeobj_v2( buf, buf_len );
}
 //  DeviceInfo
static int
DeviceInfoTypeSupport_get_encoding(  struct _TypeSupport * /*ts*/, DDS_DataRepresentationIdSeq * ids )
{
  if ( ids ) {
    DDS_DataRepresentationId_t id;
    INIT_SEQ(*ids);
    id = DDS_XCDR2_DATA_REPRESENTATION;
    seq_add(ids, &id);
    id = DDS_XCDR_DATA_REPRESENTATION;
    seq_add(ids, &id);
  }
  return 2;
}


struct _TypeSupport org::toc::coredx::topic::TypeTraits<Heartbeat>::_ts = 
  {
    HeartbeatTypeSupport_get_fully_qualified_type_name,
    HeartbeatTypeSupport_clone_ts,
    HeartbeatTypeSupport_delete_ts,
    HeartbeatTypeSupport_has_key,
    HeartbeatTypeSupport_key_must_hash,
    HeartbeatTypeSupport_marshal_fixed_size,
    HeartbeatTypeSupport_marshal_cdr,
    HeartbeatTypeSupport_marshal_key_hash,
    HeartbeatTypeSupport_unmarshal_cdr,
    HeartbeatTypeSupport_unmarshal_key_hash,
    HeartbeatTypeSupport_alloc,
    HeartbeatTypeSupport_clear,
    HeartbeatTypeSupport_destroy,
    HeartbeatTypeSupport_copy,
    HeartbeatTypeSupport_get_field,
    HeartbeatTypeSupport_gen_typeobj,
    HeartbeatTypeSupport_gen_typeid_v2,
    HeartbeatTypeSupport_gen_typeinfo_v2,
    HeartbeatTypeSupport_gen_typeobj_v2,
    HeartbeatTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<SysName>::_ts = 
  {
    SysNameTypeSupport_get_fully_qualified_type_name,
    SysNameTypeSupport_clone_ts,
    SysNameTypeSupport_delete_ts,
    SysNameTypeSupport_has_key,
    SysNameTypeSupport_key_must_hash,
    SysNameTypeSupport_marshal_fixed_size,
    SysNameTypeSupport_marshal_cdr,
    SysNameTypeSupport_marshal_key_hash,
    SysNameTypeSupport_unmarshal_cdr,
    SysNameTypeSupport_unmarshal_key_hash,
    SysNameTypeSupport_alloc,
    SysNameTypeSupport_clear,
    SysNameTypeSupport_destroy,
    SysNameTypeSupport_copy,
    SysNameTypeSupport_get_field,
    SysNameTypeSupport_gen_typeobj,
    SysNameTypeSupport_gen_typeid_v2,
    SysNameTypeSupport_gen_typeinfo_v2,
    SysNameTypeSupport_gen_typeobj_v2,
    SysNameTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<timeValue>::_ts = 
  {
    timeValueTypeSupport_get_fully_qualified_type_name,
    timeValueTypeSupport_clone_ts,
    timeValueTypeSupport_delete_ts,
    timeValueTypeSupport_has_key,
    timeValueTypeSupport_key_must_hash,
    timeValueTypeSupport_marshal_fixed_size,
    timeValueTypeSupport_marshal_cdr,
    timeValueTypeSupport_marshal_key_hash,
    timeValueTypeSupport_unmarshal_cdr,
    timeValueTypeSupport_unmarshal_key_hash,
    timeValueTypeSupport_alloc,
    timeValueTypeSupport_clear,
    timeValueTypeSupport_destroy,
    timeValueTypeSupport_copy,
    timeValueTypeSupport_get_field,
    timeValueTypeSupport_gen_typeobj,
    timeValueTypeSupport_gen_typeid_v2,
    timeValueTypeSupport_gen_typeinfo_v2,
    timeValueTypeSupport_gen_typeobj_v2,
    timeValueTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<ClockCommand>::_ts = 
  {
    ClockCommandTypeSupport_get_fully_qualified_type_name,
    ClockCommandTypeSupport_clone_ts,
    ClockCommandTypeSupport_delete_ts,
    ClockCommandTypeSupport_has_key,
    ClockCommandTypeSupport_key_must_hash,
    ClockCommandTypeSupport_marshal_fixed_size,
    ClockCommandTypeSupport_marshal_cdr,
    ClockCommandTypeSupport_marshal_key_hash,
    ClockCommandTypeSupport_unmarshal_cdr,
    ClockCommandTypeSupport_unmarshal_key_hash,
    ClockCommandTypeSupport_alloc,
    ClockCommandTypeSupport_clear,
    ClockCommandTypeSupport_destroy,
    ClockCommandTypeSupport_copy,
    ClockCommandTypeSupport_get_field,
    ClockCommandTypeSupport_gen_typeobj,
    ClockCommandTypeSupport_gen_typeid_v2,
    ClockCommandTypeSupport_gen_typeinfo_v2,
    ClockCommandTypeSupport_gen_typeobj_v2,
    ClockCommandTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<ButtonCommand>::_ts = 
  {
    ButtonCommandTypeSupport_get_fully_qualified_type_name,
    ButtonCommandTypeSupport_clone_ts,
    ButtonCommandTypeSupport_delete_ts,
    ButtonCommandTypeSupport_has_key,
    ButtonCommandTypeSupport_key_must_hash,
    ButtonCommandTypeSupport_marshal_fixed_size,
    ButtonCommandTypeSupport_marshal_cdr,
    ButtonCommandTypeSupport_marshal_key_hash,
    ButtonCommandTypeSupport_unmarshal_cdr,
    ButtonCommandTypeSupport_unmarshal_key_hash,
    ButtonCommandTypeSupport_alloc,
    ButtonCommandTypeSupport_clear,
    ButtonCommandTypeSupport_destroy,
    ButtonCommandTypeSupport_copy,
    ButtonCommandTypeSupport_get_field,
    ButtonCommandTypeSupport_gen_typeobj,
    ButtonCommandTypeSupport_gen_typeid_v2,
    ButtonCommandTypeSupport_gen_typeinfo_v2,
    ButtonCommandTypeSupport_gen_typeobj_v2,
    ButtonCommandTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<ButtonData>::_ts = 
  {
    ButtonDataTypeSupport_get_fully_qualified_type_name,
    ButtonDataTypeSupport_clone_ts,
    ButtonDataTypeSupport_delete_ts,
    ButtonDataTypeSupport_has_key,
    ButtonDataTypeSupport_key_must_hash,
    ButtonDataTypeSupport_marshal_fixed_size,
    ButtonDataTypeSupport_marshal_cdr,
    ButtonDataTypeSupport_marshal_key_hash,
    ButtonDataTypeSupport_unmarshal_cdr,
    ButtonDataTypeSupport_unmarshal_key_hash,
    ButtonDataTypeSupport_alloc,
    ButtonDataTypeSupport_clear,
    ButtonDataTypeSupport_destroy,
    ButtonDataTypeSupport_copy,
    ButtonDataTypeSupport_get_field,
    ButtonDataTypeSupport_gen_typeobj,
    ButtonDataTypeSupport_gen_typeid_v2,
    ButtonDataTypeSupport_gen_typeinfo_v2,
    ButtonDataTypeSupport_gen_typeobj_v2,
    ButtonDataTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<ArenaData>::_ts = 
  {
    ArenaDataTypeSupport_get_fully_qualified_type_name,
    ArenaDataTypeSupport_clone_ts,
    ArenaDataTypeSupport_delete_ts,
    ArenaDataTypeSupport_has_key,
    ArenaDataTypeSupport_key_must_hash,
    ArenaDataTypeSupport_marshal_fixed_size,
    ArenaDataTypeSupport_marshal_cdr,
    ArenaDataTypeSupport_marshal_key_hash,
    ArenaDataTypeSupport_unmarshal_cdr,
    ArenaDataTypeSupport_unmarshal_key_hash,
    ArenaDataTypeSupport_alloc,
    ArenaDataTypeSupport_clear,
    ArenaDataTypeSupport_destroy,
    ArenaDataTypeSupport_copy,
    ArenaDataTypeSupport_get_field,
    ArenaDataTypeSupport_gen_typeobj,
    ArenaDataTypeSupport_gen_typeid_v2,
    ArenaDataTypeSupport_gen_typeinfo_v2,
    ArenaDataTypeSupport_gen_typeobj_v2,
    ArenaDataTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
struct _TypeSupport org::toc::coredx::topic::TypeTraits<DeviceInfo>::_ts = 
  {
    DeviceInfoTypeSupport_get_fully_qualified_type_name,
    DeviceInfoTypeSupport_clone_ts,
    DeviceInfoTypeSupport_delete_ts,
    DeviceInfoTypeSupport_has_key,
    DeviceInfoTypeSupport_key_must_hash,
    DeviceInfoTypeSupport_marshal_fixed_size,
    DeviceInfoTypeSupport_marshal_cdr,
    DeviceInfoTypeSupport_marshal_key_hash,
    DeviceInfoTypeSupport_unmarshal_cdr,
    DeviceInfoTypeSupport_unmarshal_key_hash,
    DeviceInfoTypeSupport_alloc,
    DeviceInfoTypeSupport_clear,
    DeviceInfoTypeSupport_destroy,
    DeviceInfoTypeSupport_copy,
    DeviceInfoTypeSupport_get_field,
    DeviceInfoTypeSupport_gen_typeobj,
    DeviceInfoTypeSupport_gen_typeid_v2,
    DeviceInfoTypeSupport_gen_typeinfo_v2,
    DeviceInfoTypeSupport_gen_typeobj_v2,
    DeviceInfoTypeSupport_get_encoding,
    DDS_TYPESUPPORT_CPP11,
    NULL
  };
