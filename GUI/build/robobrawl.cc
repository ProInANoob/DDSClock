/********************************************
 * DDS type specific source file.           *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/
#if defined(__GNUC__)
#  pragma GCC diagnostic ignored "-Wold-style-cast"
#  pragma GCC diagnostic ignored "-Wshadow"
#endif
#include <dds/dds.hpp>
#include "robobrawl.hh"
#define s_offsetof(TYPE,field) ((size_t)((char *)&(((TYPE *)0x10)->field) - (char*)0x10))

/******************************************************************
 * ClockInfo Default Constructor
 ******************************************************************/
ClockInfo::ClockInfo()
{
  init();
}

/******************************************************************
 * ClockInfo Copy Constructor
 ******************************************************************/
ClockInfo::ClockInfo( const ClockInfo & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ClockInfo Destructor
 ******************************************************************/
ClockInfo::~ClockInfo()
{
  clear();
}

/******************************************************************
 * ClockInfo Assignment Operator
 ******************************************************************/
ClockInfo& ClockInfo::operator=( const ClockInfo & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ClockInfo::ClockInfo::operator==( const ClockInfo & other) const {
  return (_topicName == other._topicName) &&
    (_digits == other._digits) &&
    (_hasGears == other._hasGears);
}
/******************************************************************
 * ::ClockInfo Ops
 *****************************************************************/


/******************************************************************
 * ClockInfo init()
 ******************************************************************/
void ClockInfo::init()
{
  _topicName = std::string();
  this->_digits = 0;
  this->_hasGears = 0;
}

/******************************************************************
 * ClockInfo clear()
 ******************************************************************/
void ClockInfo::clear()
{
  _topicName = std::string();
  /* clear basic type: this->_digits NOOP */
  /* clear basic type: this->_hasGears NOOP */
}

/******************************************************************
 *  ClockInfo copy()
 ******************************************************************/
int ClockInfo::copy( const ClockInfo * copy_from )
{
  ClockInfo * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy topicName */
  copy_to->_topicName = copy_from->_topicName;

  /* copy digits */
  copy_to->_digits = copy_from->_digits;

  /* copy hasGears */
  copy_to->_hasGears = copy_from->_hasGears;

  return 0;
}

/******************************************************************
 *  ClockInfo::marshal_cdr()
 ******************************************************************/
int ClockInfo::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_topicName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_digits),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_hasGears),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ClockInfo::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ClockInfo::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ClockInfo::marshal_key_hash()
 ******************************************************************/
int ClockInfo::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_topicName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_digits),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_hasGears),
        2,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ClockInfo::unmarshal_cdr()
 ******************************************************************/
int ClockInfo::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ClockInfo" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_topicName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_digits),
                  1,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_hasGears),
                  2,
                  0
                  );
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_topicName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_digits),
                  1,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_hasGears),
                  2,
                  0
                  );
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ClockInfo" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ClockInfo::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ClockInfo::unmarshal_key_hash()
 ******************************************************************/
int ClockInfo::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_topicName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_digits),
              1,
              0
              );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_hasGears),
              2,
              0
              );
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ClockInfo::gen_typeid_v2( unsigned char * buf,
                   int            * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 0x97, 0x7a, 0x01, 0x9d, 0x88  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ClockInfo::gen_typeobj_v2( unsigned char * buf,
                                 int            * buf_len )
{
  static unsigned char data[235] = { 
    0xe7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0xa9, 0x8f, 0x7e, 0xea, 0xab, 0x6c, 0x20, 
    0x86, 0xad, 0x01, 0xeb, 0x93, 0xac, 0x45, 0x00, 0x43, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x2f, 0x13, 0x1b, 0x4d, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0xa2, 0xaa, 0xcb, 0xd1, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x79, 0x92, 0xa4, 0x12, 0xf2, 
    0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 0x97, 0x7a, 0x01, 0x9d, 0x88, 0x00, 0x00, 
    0x77, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 
    0x57, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x17, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x68, 0x61, 0x73, 0x47, 0x65, 0x61, 0x72, 0x73, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 235;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ClockInfo get_field_def()
 ******************************************************************/
unsigned char
ClockInfo::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("topicName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockInfo,_topicName);
    } else
      field_def->offset  += s_offsetof(struct ClockInfo,_topicName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("digits", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockInfo,_digits);
    } else
      field_def->offset  += s_offsetof(struct ClockInfo,_digits);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("hasGears", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockInfo,_hasGears);
    } else
      field_def->offset  += s_offsetof(struct ClockInfo,_hasGears);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * ButtonInfo Default Constructor
 ******************************************************************/
ButtonInfo::ButtonInfo()
{
  init();
}

/******************************************************************
 * ButtonInfo Copy Constructor
 ******************************************************************/
ButtonInfo::ButtonInfo( const ButtonInfo & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ButtonInfo Destructor
 ******************************************************************/
ButtonInfo::~ButtonInfo()
{
  clear();
}

/******************************************************************
 * ButtonInfo Assignment Operator
 ******************************************************************/
ButtonInfo& ButtonInfo::operator=( const ButtonInfo & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ButtonInfo::ButtonInfo::operator==( const ButtonInfo & other) const {
  return (_topicName == other._topicName) &&
    (_color == other._color);
}
/******************************************************************
 * ::ButtonInfo Ops
 *****************************************************************/


/******************************************************************
 * ButtonInfo init()
 ******************************************************************/
void ButtonInfo::init()
{
  _topicName = std::string();
  this->_color = 0;
}

/******************************************************************
 * ButtonInfo clear()
 ******************************************************************/
void ButtonInfo::clear()
{
  _topicName = std::string();
  /* clear basic type: this->_color NOOP */
}

/******************************************************************
 *  ButtonInfo copy()
 ******************************************************************/
int ButtonInfo::copy( const ButtonInfo * copy_from )
{
  ButtonInfo * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy topicName */
  copy_to->_topicName = copy_from->_topicName;

  /* copy color */
  copy_to->_color = copy_from->_color;

  return 0;
}

/******************************************************************
 *  ButtonInfo::marshal_cdr()
 ******************************************************************/
int ButtonInfo::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_topicName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_color),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ButtonInfo::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ButtonInfo::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ButtonInfo::marshal_key_hash()
 ******************************************************************/
int ButtonInfo::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_topicName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_color),
        1,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ButtonInfo::unmarshal_cdr()
 ******************************************************************/
int ButtonInfo::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ButtonInfo" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_topicName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_color),
                  1,
                  0
                  );
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_topicName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_color),
                  1,
                  0
                  );
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ButtonInfo" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ButtonInfo::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ButtonInfo::unmarshal_key_hash()
 ******************************************************************/
int ButtonInfo::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_topicName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_color),
              1,
              0
              );
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ButtonInfo::gen_typeid_v2( unsigned char * buf,
                   int            * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 0x19, 0xf0, 0x89  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ButtonInfo::gen_typeobj_v2( unsigned char * buf,
                                  int            * buf_len )
{
  static unsigned char data[188] = { 
    0xb8, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x97, 0x73, 0xb6, 0x31, 0xad, 0xea, 0x74, 
    0x33, 0x31, 0xb4, 0x59, 0x8a, 0x96, 0x78, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x2f, 0x13, 0x1b, 0x4d, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x70, 0xdd, 0xa5, 0xdf, 0xf2, 
    0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 0x19, 0xf0, 0x89, 0x00, 0x00, 
    0x58, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 
    0x38, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 188;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ButtonInfo get_field_def()
 ******************************************************************/
unsigned char
ButtonInfo::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("topicName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonInfo,_topicName);
    } else
      field_def->offset  += s_offsetof(struct ButtonInfo,_topicName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("color", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonInfo,_color);
    } else
      field_def->offset  += s_offsetof(struct ButtonInfo,_color);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * DeviceInfo Default Constructor
 ******************************************************************/
DeviceInfo::DeviceInfo()
{
  init();
}

/******************************************************************
 * DeviceInfo Copy Constructor
 ******************************************************************/
DeviceInfo::DeviceInfo( const DeviceInfo & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * DeviceInfo Destructor
 ******************************************************************/
DeviceInfo::~DeviceInfo()
{
  clear();
}

/******************************************************************
 * DeviceInfo Assignment Operator
 ******************************************************************/
DeviceInfo& DeviceInfo::operator=( const DeviceInfo & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
DeviceInfo::DeviceInfo::operator==( const DeviceInfo & other) const {
  return (_DeviceId == other._DeviceId) &&
    (_role == other._role) &&
    (_sysName == other._sysName) &&
    (_displayName == other._displayName) &&
    (_clockInfo == other._clockInfo) &&
    (_buttonInfo == other._buttonInfo);
}
/******************************************************************
 * ::DeviceInfo Ops
 *****************************************************************/


/******************************************************************
 * DeviceInfo init()
 ******************************************************************/
void DeviceInfo::init()
{
  _DeviceId = std::string();
  _role = std::string();
  _sysName = std::string();
  _displayName = std::string();
  // optional left empty: this->_clockInfo
  // optional left empty: this->_buttonInfo
}

/******************************************************************
 * DeviceInfo clear()
 ******************************************************************/
void DeviceInfo::clear()
{
  _DeviceId = std::string();
  _role = std::string();
  _sysName = std::string();
  _displayName = std::string();
  this->_clockInfo.reset();
  this->_buttonInfo.reset();
}

/******************************************************************
 *  DeviceInfo copy()
 ******************************************************************/
int DeviceInfo::copy( const DeviceInfo * copy_from )
{
  DeviceInfo * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy DeviceId */
  copy_to->_DeviceId = copy_from->_DeviceId;

  /* copy role */
  copy_to->_role = copy_from->_role;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  /* copy displayName */
  copy_to->_displayName = copy_from->_displayName;

  /* copy clockInfo */
  copy_to->_clockInfo = copy_from->_clockInfo;

  /* copy buttonInfo */
  copy_to->_buttonInfo = copy_from->_buttonInfo;

  return 0;
}

/******************************************************************
 *  DeviceInfo::marshal_cdr()
 ******************************************************************/
int DeviceInfo::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  if (_just_keys)
    {
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_DeviceId).c_str(),
            0,
            XCDR_IS_PRESENT,
            0 );
    }
  else
    {
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_DeviceId).c_str(),
            0,
            XCDR_IS_PRESENT,
            0 );
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_role).c_str(),
            1,
            XCDR_IS_PRESENT,
            0 );
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_sysName).c_str(),
            2,
            XCDR_IS_PRESENT,
            0 );
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_displayName).c_str(),
            3,
            XCDR_IS_PRESENT,
            0 );
      CDX_XcdrEncoder_put_member_complex( cdr,
            (this->_clockInfo)?&(*(this->_clockInfo)):NULL,
            (DDS_Type_marshal_func)ClockInfo::marshal_cdr,
            4,
            XCDR_IS_OPTIONAL | ((this->_clockInfo)?XCDR_IS_PRESENT:0),
            _just_keys);
      CDX_XcdrEncoder_put_member_complex( cdr,
            (this->_buttonInfo)?&(*(this->_buttonInfo)):NULL,
            (DDS_Type_marshal_func)ButtonInfo::marshal_cdr,
            5,
            XCDR_IS_OPTIONAL | ((this->_buttonInfo)?XCDR_IS_PRESENT:0),
            _just_keys);
    }
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int DeviceInfo::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int DeviceInfo::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  DeviceInfo::marshal_key_hash()
 ******************************************************************/
int DeviceInfo::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_DeviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  DeviceInfo::unmarshal_cdr()
 ******************************************************************/
int DeviceInfo::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "DeviceInfo" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_DeviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_DeviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_role = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                2,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                3,
                0,
                0
                );
          if (_tmpstr) {
            this->_displayName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          ClockInfo *_tmpdata = NULL;
          _rval = CDX_XcdrDecoder_get_opt_member_complex( cdr,
                (void**)(&_tmpdata),
                (DDS_Type_unmarshal_func)ClockInfo::unmarshal_cdr,
                (DDS_Type_alloc_func)ClockInfo::alloc,
                4,
                XCDR_IS_OPTIONAL,
                _just_keys );
          if (_tmpdata) {
            this->_clockInfo = *_tmpdata;
            delete _tmpdata;
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          ButtonInfo *_tmpdata = NULL;
          _rval = CDX_XcdrDecoder_get_opt_member_complex( cdr,
                (void**)(&_tmpdata),
                (DDS_Type_unmarshal_func)ButtonInfo::unmarshal_cdr,
                (DDS_Type_alloc_func)ButtonInfo::alloc,
                5,
                XCDR_IS_OPTIONAL,
                _just_keys );
          if (_tmpdata) {
            this->_buttonInfo = *_tmpdata;
            delete _tmpdata;
          }
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "DeviceInfo" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int DeviceInfo::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  DeviceInfo::unmarshal_key_hash()
 ******************************************************************/
int DeviceInfo::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_DeviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void DeviceInfo::gen_typeid_v2( unsigned char * buf,
                   int            * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x99, 0x4d, 0x16, 0xd3, 0xe9, 0x5f, 0xce, 0x5a, 0x61, 0x84, 0x9b, 0x62, 0xa5, 0x4b  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int DeviceInfo::gen_typeobj_v2( unsigned char * buf,
                                  int            * buf_len )
{
  static unsigned char data[837] = { 
    0x41, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xf1, 0xa9, 0x8f, 0x7e, 0xea, 0xab, 0x6c, 0x20, 
    0x86, 0xad, 0x01, 0xeb, 0x93, 0xac, 0x45, 0x00, 0x43, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x2f, 0x13, 0x1b, 0x4d, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0xa2, 0xaa, 0xcb, 0xd1, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x79, 0x92, 0xa4, 0x12, 0xf1, 
    0x97, 0x73, 0xb6, 0x31, 0xad, 0xea, 0x74, 0x33, 0x31, 0xb4, 0x59, 0x8a, 0x96, 0x78, 0x00, 0x00, 
    0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x2f, 0x13, 0x1b, 0x4d, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x04, 0x70, 0xdd, 0xa5, 0xdf, 0xf1, 0xec, 0x7f, 0x5e, 0x48, 0xb3, 0xbf, 0x2a, 0x34, 
    0x9b, 0x84, 0x01, 0x84, 0xd0, 0x42, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x70, 0x00, 0xd0, 0x26, 0x3c, 0x6c, 
    0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x29, 0xa7, 0xe9, 0x64, 
    0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf2, 0x6e, 0x94, 0x5d, 
    0x0c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x44, 0x98, 0xe8, 0x26, 
    0x19, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0xf1, 0xa9, 0x8f, 0x7e, 0xea, 0xab, 
    0x6c, 0x20, 0x86, 0xad, 0x01, 0xeb, 0x93, 0xac, 0x45, 0xb0, 0xa8, 0xa3, 0xec, 0x00, 0x00, 0x00, 
    0x19, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0xf1, 0x97, 0x73, 0xb6, 0x31, 0xad, 
    0xea, 0x74, 0x33, 0x31, 0xb4, 0x59, 0x8a, 0x96, 0x78, 0xd2, 0x9e, 0xb5, 0xa6, 0xf2, 0xf9, 0x6e, 
    0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 0x97, 0x7a, 0x01, 0x9d, 0x88, 0x77, 0x00, 0x00, 0x00, 
    0xf2, 0x51, 0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
    0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 
    0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 
    0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x68, 0x61, 0x73, 0x47, 
    0x65, 0x61, 0x72, 0x73, 0x00, 0x00, 0x00, 0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 
    0x17, 0xb5, 0x3e, 0x19, 0xf0, 0x89, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 
    0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0a, 0x00, 0x00, 0x00, 
    0x74, 0x6f, 0x70, 0x69, 0x63, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 
    0x72, 0x00, 0x00, 0x00, 0xf2, 0x99, 0x4d, 0x16, 0xd3, 0xe9, 0x5f, 0xce, 0x5a, 0x61, 0x84, 0x9b, 
    0x62, 0xa5, 0x4b, 0x00, 0xed, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 
    0x66, 0x6f, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 
    0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x05, 0x00, 0x00, 0x00, 0x72, 0x6f, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x69, 0x73, 0x70, 
    0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0xf2, 0xf9, 0x6e, 0x19, 0x08, 0xed, 0xd6, 0x18, 0xa6, 0x05, 
    0x97, 0x7a, 0x01, 0x9d, 0x88, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x63, 0x6c, 0x6f, 0x63, 
    0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x09, 0x00, 0xf2, 0x56, 0xac, 0xcd, 0xe9, 0xb1, 0xf7, 0x9b, 0x9e, 0x17, 0xb5, 0x3e, 0x19, 0xf0, 
    0x89, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x49, 0x6e, 
    0x66, 0x6f, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 837;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  DeviceInfo get_field_def()
 ******************************************************************/
unsigned char
DeviceInfo::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("DeviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_DeviceId);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_DeviceId);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("role", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_role);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_role);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_sysName);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("displayName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_displayName);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_displayName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("clockInfo", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct DeviceInfo, _clockInfo);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return ClockInfo::get_field_def(&fieldname[10], field_def);
  }
  if ( (strncmp("buttonInfo", fieldname, 10) == 0) && 
       (fieldname[10] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct DeviceInfo, _buttonInfo);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return ButtonInfo::get_field_def(&fieldname[11], field_def);
  }
  return 0;
}

