/********************************************
 * DDS type specific source file.           *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/
#if defined(__GNUC__)
#  pragma GCC diagnostic ignored "-Wold-style-cast"
#  pragma GCC diagnostic ignored "-Wshadow"
#endif
#include <dds/dds.hpp>
#include "robobrawl.hh"
#define s_offsetof(TYPE,field) ((size_t)((char *)&(((TYPE *)0x10)->field) - (char*)0x10))

/* ENUM DeviceRole methods */
/* ENUM Colors methods */
/* ENUM ArenaState methods */
/******************************************************************
 * Heartbeat Default Constructor
 ******************************************************************/
Heartbeat::Heartbeat()
{
  init();
}

/******************************************************************
 * Heartbeat Copy Constructor
 ******************************************************************/
Heartbeat::Heartbeat( const Heartbeat & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * Heartbeat Destructor
 ******************************************************************/
Heartbeat::~Heartbeat()
{
  clear();
}

/******************************************************************
 * Heartbeat Assignment Operator
 ******************************************************************/
Heartbeat& Heartbeat::operator=( const Heartbeat & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
Heartbeat::Heartbeat::operator==( const Heartbeat & other) const {
  return (_deviceId == other._deviceId) &&
    (_sequenceNumber == other._sequenceNumber);
}
/******************************************************************
 * ::Heartbeat Ops
 *****************************************************************/


/******************************************************************
 * Heartbeat init()
 ******************************************************************/
void Heartbeat::init()
{
  _deviceId = std::string();
  this->_sequenceNumber = 0;
}

/******************************************************************
 * Heartbeat clear()
 ******************************************************************/
void Heartbeat::clear()
{
  _deviceId = std::string();
  /* clear basic type: this->_sequenceNumber NOOP */
}

/******************************************************************
 *  Heartbeat copy()
 ******************************************************************/
int Heartbeat::copy( const Heartbeat * copy_from )
{
  Heartbeat * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy sequenceNumber */
  copy_to->_sequenceNumber = copy_from->_sequenceNumber;

  return 0;
}

/******************************************************************
 *  Heartbeat::marshal_cdr()
 ******************************************************************/
int Heartbeat::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_uint32( cdr,
        (this->_sequenceNumber),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int Heartbeat::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int Heartbeat::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  Heartbeat::marshal_key_hash()
 ******************************************************************/
int Heartbeat::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_uint32( cdr,
        (this->_sequenceNumber),
        1,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  Heartbeat::unmarshal_cdr()
 ******************************************************************/
int Heartbeat::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "Heartbeat" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_uint32( cdr,
                  &(this->_sequenceNumber),
                  1,
                  0
                  );
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_uint32( cdr,
                  &(this->_sequenceNumber),
                  1,
                  0
                  );
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "Heartbeat" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int Heartbeat::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  Heartbeat::unmarshal_key_hash()
 ******************************************************************/
int Heartbeat::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_uint32( cdr,
              &(this->_sequenceNumber),
              1,
              0
              );
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void Heartbeat::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0xf5, 0x6e, 0x21, 0x1b, 0x84, 0x28, 0x00, 0xa0, 0x94, 0x8d, 0x08, 0x04, 0x2a, 0x3b  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int Heartbeat::gen_typeobj_v2( unsigned char * buf,
                                 int32_t     * buf_len )
{
  static unsigned char data[197] = { 
    0xc1, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0xc6, 0xd3, 0x37, 0x44, 0x58, 0x31, 0xb2, 
    0x0a, 0x72, 0x6a, 0x3b, 0x3b, 0xf6, 0x16, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x67, 0x1b, 0x75, 0x0d, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x1c, 0x02, 0x1a, 0xdf, 0xf2, 
    0xf5, 0x6e, 0x21, 0x1b, 0x84, 0x28, 0x00, 0xa0, 0x94, 0x8d, 0x08, 0x04, 0x2a, 0x3b, 0x00, 0x00, 
    0x61, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x48, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x00, 0x00, 0x00, 
    0x41, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 
    0x0f, 0x00, 0x00, 0x00, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x4e, 0x75, 0x6d, 0x62, 
    0x65, 0x72, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 197;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  Heartbeat get_field_def()
 ******************************************************************/
unsigned char
Heartbeat::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct Heartbeat,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct Heartbeat,_deviceId);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sequenceNumber", fieldname)==0) {
    field_def->kind       = 4;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct Heartbeat,_sequenceNumber);
    } else
      field_def->offset  += s_offsetof(struct Heartbeat,_sequenceNumber);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * SysName Default Constructor
 ******************************************************************/
SysName::SysName()
{
  init();
}

/******************************************************************
 * SysName Copy Constructor
 ******************************************************************/
SysName::SysName( const SysName & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * SysName Destructor
 ******************************************************************/
SysName::~SysName()
{
  clear();
}

/******************************************************************
 * SysName Assignment Operator
 ******************************************************************/
SysName& SysName::operator=( const SysName & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
SysName::SysName::operator==( const SysName & other) const {
  return (_deviceId == other._deviceId) &&
    (_sysName == other._sysName);
}
/******************************************************************
 * ::SysName Ops
 *****************************************************************/


/******************************************************************
 * SysName init()
 ******************************************************************/
void SysName::init()
{
  _deviceId = std::string();
  _sysName = std::string();
}

/******************************************************************
 * SysName clear()
 ******************************************************************/
void SysName::clear()
{
  _deviceId = std::string();
  _sysName = std::string();
}

/******************************************************************
 *  SysName copy()
 ******************************************************************/
int SysName::copy( const SysName * copy_from )
{
  SysName * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  return 0;
}

/******************************************************************
 *  SysName::marshal_cdr()
 ******************************************************************/
int SysName::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int SysName::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int SysName::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  SysName::marshal_key_hash()
 ******************************************************************/
int SysName::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  SysName::unmarshal_cdr()
 ******************************************************************/
int SysName::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "SysName" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "SysName" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int SysName::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  SysName::unmarshal_key_hash()
 ******************************************************************/
int SysName::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            1,
            0,
            0
            );
      if (_tmpstr) {
        this->_sysName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void SysName::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0xe0, 0xeb, 0xc1, 0xa8, 0xe3, 0x3f, 0x07, 0xb6, 0x69, 0x6c, 0xae, 0xea, 0xd4, 0xca  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int SysName::gen_typeobj_v2( unsigned char * buf,
                               int32_t     * buf_len )
{
  static unsigned char data[186] = { 
    0xb6, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x22, 0x17, 0xbc, 0xd3, 0x8d, 0x15, 0xa4, 
    0x7d, 0xd9, 0x04, 0x13, 0x9f, 0x51, 0xd4, 0x00, 0x34, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x67, 0x1b, 0x75, 0x0d, 
    0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf2, 0x6e, 0x94, 0x5d, 
    0xf2, 0xe0, 0xeb, 0xc1, 0xa8, 0xe3, 0x3f, 0x07, 0xb6, 0x69, 0x6c, 0xae, 0xea, 0xd4, 0xca, 0x00, 
    0x56, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x53, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x3a, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 186;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  SysName get_field_def()
 ******************************************************************/
unsigned char
SysName::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct SysName,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct SysName,_deviceId);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct SysName,_sysName);
    } else
      field_def->offset  += s_offsetof(struct SysName,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * timeValue Default Constructor
 ******************************************************************/
timeValue::timeValue()
{
  init();
}

/******************************************************************
 * timeValue Copy Constructor
 ******************************************************************/
timeValue::timeValue( const timeValue & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * timeValue Destructor
 ******************************************************************/
timeValue::~timeValue()
{
  clear();
}

/******************************************************************
 * timeValue Assignment Operator
 ******************************************************************/
timeValue& timeValue::operator=( const timeValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
timeValue::timeValue::operator==( const timeValue & other) const {
  return (_seconds == other._seconds) &&
    (_minutes == other._minutes);
}
/******************************************************************
 * ::timeValue Ops
 *****************************************************************/


/******************************************************************
 * timeValue init()
 ******************************************************************/
void timeValue::init()
{
  this->_seconds = 0.0f;
  this->_minutes = 0;
}

/******************************************************************
 * timeValue clear()
 ******************************************************************/
void timeValue::clear()
{
  /* clear basic type: this->_seconds NOOP */
  /* clear basic type: this->_minutes NOOP */
}

/******************************************************************
 *  timeValue copy()
 ******************************************************************/
int timeValue::copy( const timeValue * copy_from )
{
  timeValue * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy seconds */
  copy_to->_seconds = copy_from->_seconds;

  /* copy minutes */
  copy_to->_minutes = copy_from->_minutes;

  return 0;
}

/******************************************************************
 *  timeValue::marshal_cdr()
 ******************************************************************/
int timeValue::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_float32( cdr,
        (this->_seconds),
        0,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_minutes),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int timeValue::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int timeValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  timeValue::marshal_key_hash()
 ******************************************************************/
int timeValue::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_float32( cdr,
        (this->_seconds),
        0,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_minutes),
        1,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  timeValue::unmarshal_cdr()
 ******************************************************************/
int timeValue::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "timeValue" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_float32( cdr,
                  &(this->_seconds),
                  0,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_minutes),
                  1,
                  0
                  );
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_float32( cdr,
                  &(this->_seconds),
                  0,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_minutes),
                  1,
                  0
                  );
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "timeValue" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int timeValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  timeValue::unmarshal_key_hash()
 ******************************************************************/
int timeValue::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_float32( cdr,
              &(this->_seconds),
              0,
              0
              );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_minutes),
              1,
              0
              );
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void timeValue::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int timeValue::gen_typeobj_v2( unsigned char * buf,
                                 int32_t     * buf_len )
{
  static unsigned char data[190] = { 
    0xba, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x9e, 0xc4, 0x47, 0x25, 0x7a, 0xe1, 0x1e, 
    0x3d, 0xf7, 0x9a, 0x68, 0xe1, 0x2f, 0xc6, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x78, 0x3e, 0x8e, 0x29, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x64, 0x0f, 0xd0, 0xcc, 0xf2, 
    0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89, 0x00, 0x00, 
    0x5a, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0a, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 
    0x3a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 190;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  timeValue get_field_def()
 ******************************************************************/
unsigned char
timeValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("seconds", fieldname)==0) {
    field_def->kind       = 5;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct timeValue,_seconds);
    } else
      field_def->offset  += s_offsetof(struct timeValue,_seconds);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("minutes", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct timeValue,_minutes);
    } else
      field_def->offset  += s_offsetof(struct timeValue,_minutes);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * ClockCommand Default Constructor
 ******************************************************************/
ClockCommand::ClockCommand()
{
  init();
}

/******************************************************************
 * ClockCommand Copy Constructor
 ******************************************************************/
ClockCommand::ClockCommand( const ClockCommand & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ClockCommand Destructor
 ******************************************************************/
ClockCommand::~ClockCommand()
{
  clear();
}

/******************************************************************
 * ClockCommand Assignment Operator
 ******************************************************************/
ClockCommand& ClockCommand::operator=( const ClockCommand & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ClockCommand::ClockCommand::operator==( const ClockCommand & other) const {
  return (_sysName == other._sysName) &&
    (_isOff == other._isOff) &&
    (_doDisplayTime == other._doDisplayTime) &&
    (_time == other._time) &&
    (_mainColor == other._mainColor) &&
    (_blueGearColor == other._blueGearColor) &&
    (_orangeGearColor == other._orangeGearColor);
}
/******************************************************************
 * ::ClockCommand Ops
 *****************************************************************/


/******************************************************************
 * ClockCommand init()
 ******************************************************************/
void ClockCommand::init()
{
  _sysName = std::string();
  this->_isOff = 0;
  this->_doDisplayTime = 0;
  _mainColor = Colors::COLOR_GREEN;
  _blueGearColor = Colors::COLOR_GREEN;
  _orangeGearColor = Colors::COLOR_GREEN;
}

/******************************************************************
 * ClockCommand clear()
 ******************************************************************/
void ClockCommand::clear()
{
  _sysName = std::string();
  /* clear basic type: this->_isOff NOOP */
  /* clear basic type: this->_doDisplayTime NOOP */
  /* clear struct: this->_time */
  this->_time.clear( );
  /* clear enum: this->_mainColor */
  /* clear enum: this->_blueGearColor */
  /* clear enum: this->_orangeGearColor */
}

/******************************************************************
 *  ClockCommand copy()
 ******************************************************************/
int ClockCommand::copy( const ClockCommand * copy_from )
{
  ClockCommand * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  /* copy isOff */
  copy_to->_isOff = copy_from->_isOff;

  /* copy doDisplayTime */
  copy_to->_doDisplayTime = copy_from->_doDisplayTime;

  /* copy time */
  copy_to->_time = copy_from->_time;

  /* copy mainColor */
  copy_to->_mainColor = copy_from->_mainColor;

  /* copy blueGearColor */
  copy_to->_blueGearColor = copy_from->_blueGearColor;

  /* copy orangeGearColor */
  copy_to->_orangeGearColor = copy_from->_orangeGearColor;

  return 0;
}

/******************************************************************
 *  ClockCommand::marshal_cdr()
 ******************************************************************/
int ClockCommand::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_isOff),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_doDisplayTime),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_complex( cdr,
        &((this->_time)),
        (DDS_Type_marshal_func)timeValue::marshal_cdr,
        3,
        XCDR_IS_PRESENT,
        _just_keys);
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_mainColor)),
        4,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_blueGearColor)),
        5,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_orangeGearColor)),
        6,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ClockCommand::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ClockCommand::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ClockCommand::marshal_key_hash()
 ******************************************************************/
int ClockCommand::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_isOff),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_doDisplayTime),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_keyhash( cdr,
        &((this->_time)),
        (DDS_Type_marshal_keyhash_func)timeValue::marshal_key_hash );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_mainColor)),
        4,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_blueGearColor)),
        5,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_orangeGearColor)),
        6,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ClockCommand::unmarshal_cdr()
 ******************************************************************/
int ClockCommand::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ClockCommand" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_isOff),
                  1,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_doDisplayTime),
                  2,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_complex( cdr,
              (void*)&(this->_time),
              (DDS_Type_unmarshal_func)timeValue::unmarshal_cdr,
              3,
              0,
              _just_keys );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    4,
                    0
                    );
          this->_mainColor = static_cast<Colors>(_tmp);
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    5,
                    0
                    );
          this->_blueGearColor = static_cast<Colors>(_tmp);
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    6,
                    0
                    );
          this->_orangeGearColor = static_cast<Colors>(_tmp);
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_isOff),
                  1,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_doDisplayTime),
                  2,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_complex( cdr,
              (void*)&(this->_time),
              (DDS_Type_unmarshal_func)timeValue::unmarshal_cdr,
              3,
              0,
              _just_keys );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    4,
                    0
                    );
          this->_mainColor = static_cast<Colors>(_tmp);
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    5,
                    0
                    );
          this->_blueGearColor = static_cast<Colors>(_tmp);
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    6,
                    0
                    );
          this->_orangeGearColor = static_cast<Colors>(_tmp);
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ClockCommand" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ClockCommand::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ClockCommand::unmarshal_key_hash()
 ******************************************************************/
int ClockCommand::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_sysName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_isOff),
              1,
              0
              );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_doDisplayTime),
              2,
              0
              );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    timeValue::unmarshal_key_hash( &(this->_time), cdr );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      int32_t _tmp = 0;
      _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                &_tmp,
                4,
                0
                );
      this->_mainColor = static_cast<Colors>(_tmp);
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      int32_t _tmp = 0;
      _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                &_tmp,
                5,
                0
                );
      this->_blueGearColor = static_cast<Colors>(_tmp);
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      int32_t _tmp = 0;
      _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                &_tmp,
                6,
                0
                );
      this->_orangeGearColor = static_cast<Colors>(_tmp);
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ClockCommand::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x70, 0xb0, 0x5f, 0x23, 0x47, 0xba, 0xe5, 0xf8, 0x71, 0x89, 0x96, 0x2f, 0x84, 0x60  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ClockCommand::gen_typeobj_v2( unsigned char * buf,
                                    int32_t     * buf_len )
{
  static unsigned char data[1210] = { 
    0xb6, 0x04, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xf1, 0x9e, 0xc4, 0x47, 0x25, 0x7a, 0xe1, 0x1e, 
    0x3d, 0xf7, 0x9a, 0x68, 0xe1, 0x2f, 0xc6, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x78, 0x3e, 0x8e, 0x29, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x64, 0x0f, 0xd0, 0xcc, 0xf1, 
    0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 0x78, 0x43, 0x96, 0x2d, 0x58, 0x00, 0x00, 
    0x9e, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
    0x8e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x18, 0x0a, 0x23, 0xcd, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0xc3, 0x86, 0x3f, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0xf6, 
    0x9f, 0x83, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0xde, 0xa6, 0xfe, 0xda, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x28, 0x73, 0x58, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x5c, 0xea, 0x0d, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x3a, 
    0x19, 0x18, 0xf1, 0xd9, 0x61, 0x34, 0x85, 0x09, 0x5e, 0x13, 0x88, 0xd0, 0xb5, 0xff, 0x69, 0x49, 
    0x96, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf2, 0x6e, 0x94, 0x5d, 0x0b, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x52, 0xf4, 0x1e, 0x6b, 0x00, 0x0b, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x16, 0x06, 0x30, 0x0a, 0x00, 0x19, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x9e, 0xc4, 0x47, 0x25, 0x7a, 0xe1, 0x1e, 0x3d, 0xf7, 
    0x9a, 0x68, 0xe1, 0x2f, 0xc6, 0x07, 0xcc, 0x69, 0x4b, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 
    0x78, 0x43, 0x96, 0x2d, 0x58, 0xc9, 0xa4, 0x61, 0xe3, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 
    0x78, 0x43, 0x96, 0x2d, 0x58, 0x75, 0x52, 0x09, 0x07, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 
    0x78, 0x43, 0x96, 0x2d, 0x58, 0x1c, 0xaf, 0x72, 0x42, 0xf2, 0x74, 0xb8, 0x39, 0xbb, 0x67, 0xa8, 
    0x8c, 0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89, 0x5a, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 
    0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x6d, 0x69, 0x6e, 0x75, 
    0x74, 0x65, 0x73, 0x00, 0x00, 0x00, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 
    0x4e, 0x05, 0x60, 0x29, 0xed, 0x00, 0x00, 0x00, 0x16, 0x01, 0x00, 0x00, 0xf2, 0x40, 0x02, 0x00, 
    0x0f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 
    0x72, 0x73, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x47, 0x52, 0x45, 0x45, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 
    0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x55, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x52, 0x45, 0x44, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 0x41, 0x43, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x57, 0x48, 0x49, 0x54, 0x45, 0x00, 
    0x00, 0x00, 0xf2, 0x70, 0xb0, 0x5f, 0x23, 0x47, 0xba, 0xe5, 0xf8, 0x71, 0x89, 0x96, 0x2f, 0x84, 
    0x60, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x15, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x43, 0x6f, 0x6d, 
    0x6d, 0x61, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x69, 0x73, 0x4f, 0x66, 
    0x66, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x64, 0x6f, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x69, 0x6d, 
    0x65, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x74, 
    0xb8, 0x39, 0xbb, 0x67, 0xa8, 0x8c, 0xbe, 0x77, 0xfb, 0x8c, 0xc6, 0xf4, 0x89, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 
    0x4e, 0x05, 0x60, 0x29, 0xed, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 
    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 
    0xed, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x62, 0x6c, 0x75, 0x65, 0x47, 0x65, 0x61, 0x72, 
    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 
    0xed, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x47, 0x65, 
    0x61, 0x72, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 1210;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ClockCommand get_field_def()
 ******************************************************************/
unsigned char
ClockCommand::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_sysName);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("isOff", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_isOff);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_isOff);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("doDisplayTime", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_doDisplayTime);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_doDisplayTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("time", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct ClockCommand, _time);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return timeValue::get_field_def(&fieldname[5], field_def);
  }
  if (strcmp("mainColor", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_mainColor);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_mainColor);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("blueGearColor", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_blueGearColor);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_blueGearColor);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("orangeGearColor", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ClockCommand,_orangeGearColor);
    } else
      field_def->offset  += s_offsetof(struct ClockCommand,_orangeGearColor);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * ButtonCommand Default Constructor
 ******************************************************************/
ButtonCommand::ButtonCommand()
{
  init();
}

/******************************************************************
 * ButtonCommand Copy Constructor
 ******************************************************************/
ButtonCommand::ButtonCommand( const ButtonCommand & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ButtonCommand Destructor
 ******************************************************************/
ButtonCommand::~ButtonCommand()
{
  clear();
}

/******************************************************************
 * ButtonCommand Assignment Operator
 ******************************************************************/
ButtonCommand& ButtonCommand::operator=( const ButtonCommand & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ButtonCommand::ButtonCommand::operator==( const ButtonCommand & other) const {
  return (_deviceId == other._deviceId) &&
    (_buttonState == other._buttonState);
}
/******************************************************************
 * ::ButtonCommand Ops
 *****************************************************************/


/******************************************************************
 * ButtonCommand init()
 ******************************************************************/
void ButtonCommand::init()
{
  _deviceId = std::string();
  _buttonState = Colors::COLOR_GREEN;
}

/******************************************************************
 * ButtonCommand clear()
 ******************************************************************/
void ButtonCommand::clear()
{
  _deviceId = std::string();
  /* clear enum: this->_buttonState */
}

/******************************************************************
 *  ButtonCommand copy()
 ******************************************************************/
int ButtonCommand::copy( const ButtonCommand * copy_from )
{
  ButtonCommand * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy buttonState */
  copy_to->_buttonState = copy_from->_buttonState;

  return 0;
}

/******************************************************************
 *  ButtonCommand::marshal_cdr()
 ******************************************************************/
int ButtonCommand::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_buttonState)),
        1,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ButtonCommand::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ButtonCommand::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ButtonCommand::marshal_key_hash()
 ******************************************************************/
int ButtonCommand::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_buttonState)),
        1,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ButtonCommand::unmarshal_cdr()
 ******************************************************************/
int ButtonCommand::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ButtonCommand" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    1,
                    0
                    );
          this->_buttonState = static_cast<Colors>(_tmp);
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    1,
                    0
                    );
          this->_buttonState = static_cast<Colors>(_tmp);
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ButtonCommand" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ButtonCommand::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ButtonCommand::unmarshal_key_hash()
 ******************************************************************/
int ButtonCommand::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      int32_t _tmp = 0;
      _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                &_tmp,
                1,
                0
                );
      this->_buttonState = static_cast<Colors>(_tmp);
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ButtonCommand::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x9e, 0x66, 0xcc, 0xf0, 0x06, 0xba, 0xe8, 0x22, 0x1f, 0x43, 0x0b, 0x39, 0xda, 0x2e  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ButtonCommand::gen_typeobj_v2( unsigned char * buf,
                                     int32_t     * buf_len )
{
  static unsigned char data[706] = { 
    0xbe, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf1, 0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 
    0xff, 0x4c, 0x78, 0x43, 0x96, 0x2d, 0x58, 0x00, 0x9e, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x02, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x18, 0x0a, 
    0x23, 0xcd, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x2d, 0xc3, 0x86, 0x3f, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0xf6, 0x9f, 0x83, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xa6, 0xfe, 0xda, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x28, 
    0x73, 0x58, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x5e, 0x5c, 0xea, 0x0d, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x3a, 0x19, 0x18, 0xf1, 0x96, 0xbc, 0xc2, 0xcf, 0x58, 
    0x97, 0x96, 0x92, 0xff, 0x25, 0xab, 0xab, 0xd0, 0xd3, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 
    0xf1, 0x51, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x67, 0x1b, 0x75, 0x0d, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x94, 
    0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 0x78, 0x43, 0x96, 0x2d, 0x58, 0x1a, 0x3b, 0x30, 
    0xf5, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 0xed, 
    0x16, 0x01, 0x00, 0x00, 0xf2, 0x40, 0x02, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x47, 0x52, 
    0x45, 0x45, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 0x55, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x52, 0x45, 
    0x44, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x41, 0x43, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x57, 0x48, 0x49, 0x54, 0x45, 0x00, 0x00, 0x00, 0xf2, 0x9e, 0x66, 0xcc, 0xf0, 0x06, 
    0xba, 0xe8, 0x22, 0x1f, 0x43, 0x0b, 0x39, 0xda, 0x2e, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
    0xf2, 0x51, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x00, 0x00, 0x00, 
    0x4e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xb7, 
    0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 0xed, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 
    0x00, 0x00  }; 
  int32_t _rlen    = 706;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ButtonCommand get_field_def()
 ******************************************************************/
unsigned char
ButtonCommand::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonCommand,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct ButtonCommand,_deviceId);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("buttonState", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonCommand,_buttonState);
    } else
      field_def->offset  += s_offsetof(struct ButtonCommand,_buttonState);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * ButtonData Default Constructor
 ******************************************************************/
ButtonData::ButtonData()
{
  init();
}

/******************************************************************
 * ButtonData Copy Constructor
 ******************************************************************/
ButtonData::ButtonData( const ButtonData & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ButtonData Destructor
 ******************************************************************/
ButtonData::~ButtonData()
{
  clear();
}

/******************************************************************
 * ButtonData Assignment Operator
 ******************************************************************/
ButtonData& ButtonData::operator=( const ButtonData & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ButtonData::ButtonData::operator==( const ButtonData & other) const {
  return (_deviceId == other._deviceId) &&
    (_sysName == other._sysName) &&
    (_mainPressed == other._mainPressed) &&
    (_tapoutPressed == other._tapoutPressed);
}
/******************************************************************
 * ::ButtonData Ops
 *****************************************************************/


/******************************************************************
 * ButtonData init()
 ******************************************************************/
void ButtonData::init()
{
  _deviceId = std::string();
  _sysName = std::string();
  this->_mainPressed = 0;
  this->_tapoutPressed = 0;
}

/******************************************************************
 * ButtonData clear()
 ******************************************************************/
void ButtonData::clear()
{
  _deviceId = std::string();
  _sysName = std::string();
  /* clear basic type: this->_mainPressed NOOP */
  /* clear basic type: this->_tapoutPressed NOOP */
}

/******************************************************************
 *  ButtonData copy()
 ******************************************************************/
int ButtonData::copy( const ButtonData * copy_from )
{
  ButtonData * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  /* copy mainPressed */
  copy_to->_mainPressed = copy_from->_mainPressed;

  /* copy tapoutPressed */
  copy_to->_tapoutPressed = copy_from->_tapoutPressed;

  return 0;
}

/******************************************************************
 *  ButtonData::marshal_cdr()
 ******************************************************************/
int ButtonData::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_mainPressed),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_tapoutPressed),
        3,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ButtonData::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ButtonData::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ButtonData::marshal_key_hash()
 ******************************************************************/
int ButtonData::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_mainPressed),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (this->_tapoutPressed),
        3,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ButtonData::unmarshal_cdr()
 ******************************************************************/
int ButtonData::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ButtonData" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_mainPressed),
                  2,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_tapoutPressed),
                  3,
                  0
                  );
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_mainPressed),
                  2,
                  0
                  );
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                  &(this->_tapoutPressed),
                  3,
                  0
                  );
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ButtonData" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ButtonData::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ButtonData::unmarshal_key_hash()
 ******************************************************************/
int ButtonData::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            1,
            0,
            0
            );
      if (_tmpstr) {
        this->_sysName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_mainPressed),
              2,
              0
              );
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    _rval = CDX_XcdrDecoder_get_member_int32( cdr,
              &(this->_tapoutPressed),
              3,
              0
              );
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ButtonData::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x06, 0x21, 0x88, 0x34, 0x3c, 0x9f, 0x1f, 0x36, 0x73, 0x3b, 0x2b, 0x58, 0xb0, 0x18  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ButtonData::gen_typeobj_v2( unsigned char * buf,
                                  int32_t     * buf_len )
{
  static unsigned char data[288] = { 
    0x1c, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x3b, 0xa1, 0x60, 0x28, 0x86, 0xc6, 0x84, 
    0x7f, 0xc2, 0x21, 0xbc, 0xf1, 0x18, 0x9a, 0x00, 0x53, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x67, 0x1b, 0x75, 0x0d, 
    0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf2, 0x6e, 0x94, 0x5d, 
    0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0xbb, 0x2f, 0xf9, 0xb4, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x47, 0x4a, 0xd4, 0xfe, 0xf2, 
    0x06, 0x21, 0x88, 0x34, 0x3c, 0x9f, 0x1f, 0x36, 0x73, 0x3b, 0x2b, 0x58, 0xb0, 0x18, 0x00, 0x00, 
    0x9c, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 
    0x7c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x6d, 0x61, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x74, 0x61, 0x70, 0x6f, 0x75, 0x74, 0x50, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 288;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ButtonData get_field_def()
 ******************************************************************/
unsigned char
ButtonData::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonData,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct ButtonData,_deviceId);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonData,_sysName);
    } else
      field_def->offset  += s_offsetof(struct ButtonData,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("mainPressed", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonData,_mainPressed);
    } else
      field_def->offset  += s_offsetof(struct ButtonData,_mainPressed);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("tapoutPressed", fieldname)==0) {
    field_def->kind       = 2;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ButtonData,_tapoutPressed);
    } else
      field_def->offset  += s_offsetof(struct ButtonData,_tapoutPressed);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * ArenaCommand Default Constructor
 ******************************************************************/
ArenaCommand::ArenaCommand()
{
  init();
}

/******************************************************************
 * ArenaCommand Copy Constructor
 ******************************************************************/
ArenaCommand::ArenaCommand( const ArenaCommand & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * ArenaCommand Destructor
 ******************************************************************/
ArenaCommand::~ArenaCommand()
{
  clear();
}

/******************************************************************
 * ArenaCommand Assignment Operator
 ******************************************************************/
ArenaCommand& ArenaCommand::operator=( const ArenaCommand & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
ArenaCommand::ArenaCommand::operator==( const ArenaCommand & other) const {
  return (_deviceId == other._deviceId) &&
    (_sysName == other._sysName) &&
    (_color == other._color);
}
/******************************************************************
 * ::ArenaCommand Ops
 *****************************************************************/


/******************************************************************
 * ArenaCommand init()
 ******************************************************************/
void ArenaCommand::init()
{
  _deviceId = std::string();
  _sysName = std::string();
  _color = Colors::COLOR_GREEN;
}

/******************************************************************
 * ArenaCommand clear()
 ******************************************************************/
void ArenaCommand::clear()
{
  _deviceId = std::string();
  _sysName = std::string();
  /* clear enum: this->_color */
}

/******************************************************************
 *  ArenaCommand copy()
 ******************************************************************/
int ArenaCommand::copy( const ArenaCommand * copy_from )
{
  ArenaCommand * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  /* copy color */
  copy_to->_color = copy_from->_color;

  return 0;
}

/******************************************************************
 *  ArenaCommand::marshal_cdr()
 ******************************************************************/
int ArenaCommand::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_color)),
        2,
        XCDR_IS_PRESENT
        );
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int ArenaCommand::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int ArenaCommand::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  ArenaCommand::marshal_key_hash()
 ******************************************************************/
int ArenaCommand::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_sysName).c_str(),
        1,
        XCDR_IS_PRESENT,
        0 );
  CDX_XcdrEncoder_put_member_int32( cdr,
        (int32_t)((this->_color)),
        2,
        XCDR_IS_PRESENT
        );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  ArenaCommand::unmarshal_cdr()
 ******************************************************************/
int ArenaCommand::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "ArenaCommand" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    2,
                    0
                    );
          this->_color = static_cast<Colors>(_tmp);
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                0,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                1,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    2,
                    0
                    );
          this->_color = static_cast<Colors>(_tmp);
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "ArenaCommand" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int ArenaCommand::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  ArenaCommand::unmarshal_key_hash()
 ******************************************************************/
int ArenaCommand::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            0,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            1,
            0,
            0
            );
      if (_tmpstr) {
        this->_sysName = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
    if ( _rval < 0 )
      return _rval;
  }
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      int32_t _tmp = 0;
      _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                &_tmp,
                2,
                0
                );
      this->_color = static_cast<Colors>(_tmp);
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void ArenaCommand::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x66, 0xa2, 0xc1, 0x48, 0xc5, 0xfe, 0x4f, 0xda, 0x04, 0x2a, 0x09, 0x07, 0xd5, 0x69  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int ArenaCommand::gen_typeobj_v2( unsigned char * buf,
                                    int32_t     * buf_len )
{
  static unsigned char data[744] = { 
    0xe4, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf1, 0x94, 0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 
    0xff, 0x4c, 0x78, 0x43, 0x96, 0x2d, 0x58, 0x00, 0x9e, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x02, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x18, 0x0a, 
    0x23, 0xcd, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x2d, 0xc3, 0x86, 0x3f, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0xf6, 0x9f, 0x83, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xa6, 0xfe, 0xda, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x28, 
    0x73, 0x58, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x5e, 0x5c, 0xea, 0x0d, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x3a, 0x19, 0x18, 0xf1, 0x4a, 0x7d, 0x08, 0xff, 0x7d, 
    0x1e, 0x4c, 0xec, 0x00, 0x94, 0x2e, 0x64, 0x7a, 0x88, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
    0xf1, 0x51, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x67, 0x1b, 0x75, 0x0d, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0xf2, 0x6e, 0x94, 0x5d, 0x19, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x94, 
    0x04, 0x48, 0x57, 0xf9, 0xc9, 0x89, 0xff, 0x4c, 0x78, 0x43, 0x96, 0x2d, 0x58, 0x70, 0xdd, 0xa5, 
    0xdf, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 0xed, 
    0x16, 0x01, 0x00, 0x00, 0xf2, 0x40, 0x02, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 
    0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x47, 0x52, 
    0x45, 0x45, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 
    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 0x55, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0d, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x59, 0x45, 0x4c, 0x4c, 0x4f, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x52, 0x45, 
    0x44, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x5f, 0x42, 0x4c, 
    0x41, 0x43, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
    0x52, 0x5f, 0x57, 0x48, 0x49, 0x54, 0x45, 0x00, 0x00, 0x00, 0xf2, 0x66, 0xa2, 0xc1, 0x48, 0xc5, 
    0xfe, 0x4f, 0xda, 0x04, 0x2a, 0x09, 0x07, 0xd5, 0x69, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
    0xf2, 0x51, 0x02, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x41, 0x72, 0x65, 0x6e, 0x61, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 
    0x64, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xb7, 0xa4, 0x47, 0xc6, 0xf8, 
    0x63, 0xd7, 0xd8, 0x1d, 0x4e, 0x05, 0x60, 0x29, 0xed, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 744;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  ArenaCommand get_field_def()
 ******************************************************************/
unsigned char
ArenaCommand::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ArenaCommand,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct ArenaCommand,_deviceId);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ArenaCommand,_sysName);
    } else
      field_def->offset  += s_offsetof(struct ArenaCommand,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("color", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct ArenaCommand,_color);
    } else
      field_def->offset  += s_offsetof(struct ArenaCommand,_color);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * DeviceInfo Default Constructor
 ******************************************************************/
DeviceInfo::DeviceInfo()
{
  init();
}

/******************************************************************
 * DeviceInfo Copy Constructor
 ******************************************************************/
DeviceInfo::DeviceInfo( const DeviceInfo & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * DeviceInfo Destructor
 ******************************************************************/
DeviceInfo::~DeviceInfo()
{
  clear();
}

/******************************************************************
 * DeviceInfo Assignment Operator
 ******************************************************************/
DeviceInfo& DeviceInfo::operator=( const DeviceInfo & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

bool
DeviceInfo::DeviceInfo::operator==( const DeviceInfo & other) const {
  return (_deviceId == other._deviceId) &&
    (_role == other._role) &&
    (_sysName == other._sysName) &&
    (_displayName == other._displayName);
}
/******************************************************************
 * ::DeviceInfo Ops
 *****************************************************************/


/******************************************************************
 * DeviceInfo init()
 ******************************************************************/
void DeviceInfo::init()
{
  _deviceId = std::string();
  _role = DeviceRole::ROLE_UNKNOWN;
  _sysName = std::string();
  _displayName = std::string();
}

/******************************************************************
 * DeviceInfo clear()
 ******************************************************************/
void DeviceInfo::clear()
{
  _deviceId = std::string();
  /* clear enum: this->_role */
  _sysName = std::string();
  _displayName = std::string();
}

/******************************************************************
 *  DeviceInfo copy()
 ******************************************************************/
int DeviceInfo::copy( const DeviceInfo * copy_from )
{
  DeviceInfo * copy_to = this;
  if ( ! copy_from ) return -1;

  /* copy deviceId */
  copy_to->_deviceId = copy_from->_deviceId;

  /* copy role */
  copy_to->_role = copy_from->_role;

  /* copy sysName */
  copy_to->_sysName = copy_from->_sysName;

  /* copy displayName */
  copy_to->_displayName = copy_from->_displayName;

  return 0;
}

/******************************************************************
 *  DeviceInfo::marshal_cdr()
 ******************************************************************/
int DeviceInfo::marshal_cdr( CDX_XcdrEncoder_t * cdr,
                   int             _just_keys) const 
{
  int32_t _rval = 0;
  CDX_XcdrEncoder_aggregate_pre( cdr, XCDR_APPENDABLE );
  if (_just_keys)
    {
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_deviceId).c_str(),
            0,
            XCDR_IS_PRESENT | XCDR_MUST_UNDERSTAND,
            0 );
    }
  else
    {
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_deviceId).c_str(),
            0,
            XCDR_IS_PRESENT | XCDR_MUST_UNDERSTAND,
            0 );
      CDX_XcdrEncoder_put_member_int32( cdr,
            (int32_t)((this->_role)),
            1,
            XCDR_IS_PRESENT
            );
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_sysName).c_str(),
            2,
            XCDR_IS_PRESENT,
            0 );
      CDX_XcdrEncoder_put_member_string( cdr,
            (this->_displayName).c_str(),
            3,
            XCDR_IS_PRESENT,
            0 );
    }
  CDX_XcdrEncoder_aggregate_post( cdr, XCDR_APPENDABLE );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position( cdr );
}

int DeviceInfo::get_marshal_size( int   offset,
                   int   _just_keys) const
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_Xcdr1Encoder_init( &xcdr1, 0x00, NULL, 0 );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
int DeviceInfo::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             _just_keys) const 
{
  int _rval;
  CDX_Xcdr1Encoder_t   xcdr1;
  CDX_XcdrEncoder_t  * cdr = &xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Encoder_init( &xcdr1, e, buf, stream_len );
  xcdr1.xcdr_buffer->origin = offset;
  xcdr1.xcdr_buffer->offset = offset;
  _rval = this->marshal_cdr( cdr, _just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrEncoder_get_position( cdr );
  CDX_Xcdr1Encoder_clear( &xcdr1 );
  return _rval;
}
/******************************************************************
 *  DeviceInfo::marshal_key_hash()
 ******************************************************************/
int DeviceInfo::marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const 
{
  int32_t _rval      = 0;
  int32_t _just_keys = 1;
  CDX_UNUSED( _just_keys );
  CDX_XcdrEncoder_put_member_string( cdr,
        (this->_deviceId).c_str(),
        0,
        XCDR_IS_PRESENT | XCDR_MUST_UNDERSTAND,
        0 );
  if ( _rval < 0 )
    return _rval;
  return CDX_XcdrEncoder_get_position(cdr);
}

/******************************************************************
 *  DeviceInfo::unmarshal_cdr()
 ******************************************************************/
int DeviceInfo::unmarshal_cdr( CDX_XcdrDecoder_t * cdr,
                   int             _just_keys)
{
  int32_t _rval = 0;
  this->init( );
  _rval = CDX_XcdrDecoder_aggregate_pre( cdr, XCDR_APPENDABLE, "DeviceInfo" );
  if ( _rval < 0 ) return _rval;
  if (_just_keys)
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                XCDR_MUST_UNDERSTAND,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
      }
    }
  else
    {
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                0,
                XCDR_MUST_UNDERSTAND,
                0
                );
          if (_tmpstr) {
            this->_deviceId = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          int32_t _tmp = 0;
          _rval = CDX_XcdrDecoder_get_member_int32( cdr,
                    &_tmp,
                    1,
                    0
                    );
          this->_role = static_cast<DeviceRole>(_tmp);
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                2,
                0,
                0
                );
          if (_tmpstr) {
            this->_sysName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
        if ( _rval < 0 )
          return _rval;
      }
      if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
        {
          char * _tmpstr = NULL;
          _rval = CDX_XcdrDecoder_get_member_string( cdr,
                &_tmpstr,
                CoreDX_DDS_calloc,
                3,
                0,
                0
                );
          if (_tmpstr) {
            this->_displayName = std::string( _tmpstr );
            CoreDX_DDS_free( _tmpstr );
          }
        }
      }
    }
  CDX_XcdrDecoder_aggregate_post( cdr, XCDR_APPENDABLE, "DeviceInfo" );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

int DeviceInfo::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  int _rval;
  CDX_Xcdr1Decoder_t  xcdr1;
  CDX_XcdrDecoder_t * cdr = (CDX_XcdrDecoder_t*)&xcdr1.base;
  CDX_XCDR_HOST_ENDIAN(e);
  if (swap) e = (e?0:1);
  CDX_Xcdr1Decoder_init( &xcdr1, e, buf, stream_len );
  cdr->xcdr_buffer.origin = offset;
  cdr->xcdr_buffer.offset = offset;
  _rval = this->unmarshal_cdr( cdr, just_keys );
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  CDX_XcdrDecoder_clear( cdr );
  return _rval;
}
/******************************************************************
 *  DeviceInfo::unmarshal_key_hash()
 ******************************************************************/
int DeviceInfo::unmarshal_key_hash( CDX_XcdrDecoder_t * cdr )
{
  int32_t _rval = 0;
  uint32_t _just_keys = 1;
  CDX_UNUSED(_just_keys);
  if ( CDX_XcdrDecoder_get_position(cdr) < CDX_XcdrDecoder_get_datalen(cdr) ) {
    {
      char * _tmpstr = NULL;
      _rval = CDX_XcdrDecoder_get_member_string( cdr,
            &_tmpstr,
            CoreDX_DDS_calloc,
            0,
            XCDR_MUST_UNDERSTAND,
            0
            );
      if (_tmpstr) {
        this->_deviceId = std::string( _tmpstr );
        CoreDX_DDS_free( _tmpstr );
      }
    }
  }
  if ( _rval >= 0 ) 
    _rval = CDX_XcdrDecoder_get_position( cdr );
  return _rval;
}

void DeviceInfo::gen_typeid_v2( unsigned char * buf,
                   int32_t          * buf_len )
{
  static unsigned char data[15] = { 
    0xf2, 0x4a, 0x6e, 0x18, 0xad, 0x6e, 0xf9, 0x6d, 0x6d, 0xf9, 0x99, 0xe8, 0xbf, 0xc6, 0xec  }; 
  if (buf && buf_len && (*buf_len >= 15))
    {
       memcpy(buf, data, 15);
    }
  if (buf_len) *buf_len = 15;
}
int DeviceInfo::gen_typeobj_v2( unsigned char * buf,
                                  int32_t     * buf_len )
{
  static unsigned char data[750] = { 
    0xea, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf1, 0x1a, 0xd1, 0x98, 0xb1, 0x20, 0xa3, 0x90, 
    0x93, 0x72, 0xb1, 0xa1, 0x70, 0x71, 0xc9, 0x00, 0x8a, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x02, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0xbc, 
    0x45, 0x9f, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x8a, 0x7d, 0xb5, 0xfa, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0x6f, 0x29, 0x37, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x28, 0x16, 0x85, 0x00, 0x00, 
    0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8b, 
    0x0e, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0xf8, 0x8e, 0x13, 0x1e, 0xf1, 0xba, 0x17, 0x86, 0x0f, 0x85, 0x60, 0x1d, 0x16, 0x52, 
    0xa1, 0x6e, 0x21, 0x60, 0x2c, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x70, 0x00, 0x67, 0x1b, 0x75, 0x0d, 
    0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x1a, 0xd1, 0x98, 0xb1, 0x20, 
    0xa3, 0x90, 0x93, 0x72, 0xb1, 0xa1, 0x70, 0x71, 0xc9, 0x29, 0xa7, 0xe9, 0x64, 0x00, 0x00, 0x00, 
    0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf2, 0x6e, 0x94, 0x5d, 
    0x0c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x44, 0x98, 0xe8, 0x26, 
    0xf2, 0xe1, 0xc7, 0xea, 0x82, 0x4f, 0x11, 0xcf, 0x36, 0x86, 0x65, 0xb9, 0xdb, 0x60, 0x40, 0x00, 
    0x05, 0x01, 0x00, 0x00, 0xf2, 0x40, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
    0x0b, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x00, 0x00, 
    0xe5, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 
    0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x00, 0x00, 0x00, 0x00, 
    0x25, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x42, 0x55, 0x54, 0x54, 0x4f, 0x4e, 0x5f, 
    0x4f, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 
    0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 
    0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x42, 0x55, 0x54, 0x54, 0x4f, 0x4e, 0x5f, 0x42, 0x4c, 0x55, 0x45, 
    0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x43, 0x4c, 0x4f, 
    0x43, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x52, 0x4f, 0x4c, 0x45, 
    0x5f, 0x41, 0x52, 0x45, 0x4e, 0x41, 0x00, 0x00, 0x00, 0xf2, 0x4a, 0x6e, 0x18, 0xad, 0x6e, 0xf9, 
    0x6d, 0x6d, 0xf9, 0x99, 0xe8, 0xbf, 0xc6, 0xec, 0xa2, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, 
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x44, 0x65, 0x76, 0x69, 
    0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x70, 0x00, 0x09, 0x00, 0x00, 0x00, 
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xe1, 0xc7, 0xea, 0x82, 0x4f, 0x11, 0xcf, 0x36, 0x86, 
    0x65, 0xb9, 0xdb, 0x60, 0x40, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x72, 0x6f, 0x6c, 0x65, 
    0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 
    0x08, 0x00, 0x00, 0x00, 0x73, 0x79, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x00, 0x00, 
    0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00  }; 
  int32_t _rlen    = 750;
  if ( buf_len == NULL )                return -1;
  if ( buf && ( *buf_len < _rlen + 4) ) return -1;
  *buf_len = _rlen + 4;
  if ( buf ) {
    buf[0] = 0;
    buf[1] = XCDR_PLAIN_CDR2 | 1;
    buf[2] = 0;
    buf[3] = 0;
    memcpy( buf+4, data, _rlen );
  }
  return 0;
}
/******************************************************************
 *  DeviceInfo get_field_def()
 ******************************************************************/
unsigned char
DeviceInfo::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  CDX_UNUSED(fieldname);
  CDX_UNUSED(field_def);
  if ( field_def == NULL) return 0;
  if (strcmp("deviceId", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_deviceId);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_deviceId);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("role", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_role);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_role);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sysName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_sysName);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_sysName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("displayName", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct DeviceInfo,_displayName);
    } else
      field_def->offset  += s_offsetof(struct DeviceInfo,_displayName);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

