/********************************************
 * DDS type specific header file.           *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/

#ifndef _ROBOBRAWL_HH
#define _ROBOBRAWL_HH
#include <dds/dds.hpp>
#include <dds/dds_seq.hh>

#  define  ROBOBRAWL_CPP_DDL_VERSION_MAJOR       6
#  define  ROBOBRAWL_CPP_DDL_VERSION_MINOR       0
#  define  ROBOBRAWL_CPP_DDL_VERSION_PATCH       5
#  define  ROBOBRAWL_CPP_DDL_VERSION_MAJOR_STR  "6"
#  define  ROBOBRAWL_CPP_DDL_VERSION_MINOR_STR  "0"
#  define  ROBOBRAWL_CPP_DDL_VERSION_PATCH_STR  "5"

#include <iostream>
#include <iomanip>
#ifdef _MSC_VER
#  pragma warning(push)
#endif
  struct COREDX_TS_STRUCT_EXPORT ClockInfo {
    public:
      ClockInfo();
      ~ClockInfo();
      ClockInfo( const std::string __topicName,
                 const int32_t __digits,
                 const int32_t __hasGears ) :
        _topicName( __topicName ),
        _digits( __digits ),
        _hasGears( __hasGears ){ }
      ClockInfo( const ClockInfo & other );
      ClockInfo& operator=( const ClockInfo & other);

      bool operator==( const ClockInfo & other) const;
      bool operator!=( const ClockInfo & other) const { return !operator==(other); }

      /* TypeId: [ C_f96e1908edd618a605977a019d88 :: M_a98f7eeaab6c2086ad01eb93ac45 ] */
      void   init();
      void   clear();
      int    copy( const ClockInfo * instance );

      int  marshal_cdr( CDX_XcdrEncoder_t *cdr, int just_keys) const ;
      int  marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const;
      int  unmarshal_cdr( CDX_XcdrDecoder_t * cdr, int just_keys);
      int  unmarshal_key_hash( CDX_XcdrDecoder_t * cdr );
      // deprecated api:
      int  get_marshal_size( int offset, int just_keys ) const;
      int  marshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys) const ;
      int  unmarshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys);

      static void * alloc() { return new ClockInfo; }
      static int    marshal_cdr( const void * instance, CDX_XcdrEncoder_t *cdr, int just_keys) 
                         { return ((ClockInfo*)instance)->marshal_cdr( cdr, just_keys ); }
      static int    marshal_key_hash( const void * instance, CDX_XcdrEncoder_t *cdr) 
                         { return ((ClockInfo*)instance)->marshal_key_hash( cdr ); }
      static int    unmarshal_cdr( void * instance, CDX_XcdrDecoder_t * cdr, int just_keys) 
                         { return ((ClockInfo*)instance)->unmarshal_cdr( cdr, just_keys ); }
      static int    unmarshal_key_hash( void * instance, CDX_XcdrDecoder_t * cdr) 
                         { return ((ClockInfo*)instance)->unmarshal_key_hash( cdr ); }

      static void      gen_typeid_v2 ( unsigned char * buf, int * buf_len );
      static int       gen_typeobj_v2 ( unsigned char * buf, int * buf_len );

      static unsigned char get_field_def(const char  * fieldname, 
                                         CoreDX_FieldDef_t * field_def);
    protected:
      std::string  _topicName;    /* ID: 0x00000000 */
      int32_t  _digits;    /* ID: 0x00000001 */
      int32_t  _hasGears;    /* ID: 0x00000002 */

    public:
      const std::string & topicName( ) const { return _topicName; }
            std::string & topicName( )       { return _topicName; }
      void  topicName( const std::string &  __topicName ) {  _topicName = __topicName; }
      void  topicName( const std::string && __topicName ) {  _topicName = __topicName; }
            int32_t   digits( ) const { return _digits; }
            int32_t & digits( )       { return _digits; }
      void digits( const int32_t __digits ) { _digits = __digits; }
            int32_t   hasGears( ) const { return _hasGears; }
            int32_t & hasGears( )       { return _hasGears; }
      void hasGears( const int32_t __hasGears ) { _hasGears = __hasGears; }

      typedef dds::sub::DataReader<ClockInfo>  DataReader;
      typedef dds::pub::DataWriter<ClockInfo>  DataWriter;

    private:

  }; //ClockInfo
  typedef dds::sub::DataReader<ClockInfo>  ClockInfoDataReader;
  typedef dds::pub::DataWriter<ClockInfo>  ClockInfoDataWriter;

  struct COREDX_TS_STRUCT_EXPORT ButtonInfo {
    public:
      ButtonInfo();
      ~ButtonInfo();
      ButtonInfo( const std::string __topicName,
                  const int32_t __color ) :
        _topicName( __topicName ),
        _color( __color ){ }
      ButtonInfo( const ButtonInfo & other );
      ButtonInfo& operator=( const ButtonInfo & other);

      bool operator==( const ButtonInfo & other) const;
      bool operator!=( const ButtonInfo & other) const { return !operator==(other); }

      /* TypeId: [ C_56accde9b1f79b9e17b53e19f089 :: M_9773b631adea743331b4598a9678 ] */
      void   init();
      void   clear();
      int    copy( const ButtonInfo * instance );

      int  marshal_cdr( CDX_XcdrEncoder_t *cdr, int just_keys) const ;
      int  marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const;
      int  unmarshal_cdr( CDX_XcdrDecoder_t * cdr, int just_keys);
      int  unmarshal_key_hash( CDX_XcdrDecoder_t * cdr );
      // deprecated api:
      int  get_marshal_size( int offset, int just_keys ) const;
      int  marshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys) const ;
      int  unmarshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys);

      static void * alloc() { return new ButtonInfo; }
      static int    marshal_cdr( const void * instance, CDX_XcdrEncoder_t *cdr, int just_keys) 
                         { return ((ButtonInfo*)instance)->marshal_cdr( cdr, just_keys ); }
      static int    marshal_key_hash( const void * instance, CDX_XcdrEncoder_t *cdr) 
                         { return ((ButtonInfo*)instance)->marshal_key_hash( cdr ); }
      static int    unmarshal_cdr( void * instance, CDX_XcdrDecoder_t * cdr, int just_keys) 
                         { return ((ButtonInfo*)instance)->unmarshal_cdr( cdr, just_keys ); }
      static int    unmarshal_key_hash( void * instance, CDX_XcdrDecoder_t * cdr) 
                         { return ((ButtonInfo*)instance)->unmarshal_key_hash( cdr ); }

      static void      gen_typeid_v2 ( unsigned char * buf, int * buf_len );
      static int       gen_typeobj_v2 ( unsigned char * buf, int * buf_len );

      static unsigned char get_field_def(const char  * fieldname, 
                                         CoreDX_FieldDef_t * field_def);
    protected:
      std::string  _topicName;    /* ID: 0x00000000 */
      int32_t  _color;    /* ID: 0x00000001 */

    public:
      const std::string & topicName( ) const { return _topicName; }
            std::string & topicName( )       { return _topicName; }
      void  topicName( const std::string &  __topicName ) {  _topicName = __topicName; }
      void  topicName( const std::string && __topicName ) {  _topicName = __topicName; }
            int32_t   color( ) const { return _color; }
            int32_t & color( )       { return _color; }
      void color( const int32_t __color ) { _color = __color; }

      typedef dds::sub::DataReader<ButtonInfo>  DataReader;
      typedef dds::pub::DataWriter<ButtonInfo>  DataWriter;

    private:

  }; //ButtonInfo
  typedef dds::sub::DataReader<ButtonInfo>  ButtonInfoDataReader;
  typedef dds::pub::DataWriter<ButtonInfo>  ButtonInfoDataWriter;

  struct COREDX_TS_STRUCT_EXPORT DeviceInfo {
    public:
      DeviceInfo();
      ~DeviceInfo();
      DeviceInfo( const std::string __DeviceId,
                  const std::string __role,
                  const std::string __sysName,
                  const std::string __displayName,
                  const dds::core::optional<struct ClockInfo> __clockInfo,
                  const dds::core::optional<struct ButtonInfo> __buttonInfo ) :
        _DeviceId( __DeviceId ),
        _role( __role ),
        _sysName( __sysName ),
        _displayName( __displayName ),
        _clockInfo( __clockInfo ),
        _buttonInfo( __buttonInfo ){ }
      DeviceInfo( const DeviceInfo & other );
      DeviceInfo& operator=( const DeviceInfo & other);

      bool operator==( const DeviceInfo & other) const;
      bool operator!=( const DeviceInfo & other) const { return !operator==(other); }

      /* TypeId: [ C_994d16d3e95fce5a61849b62a54b :: M_ec7f5e48b3bf2a349b840184d042 ] */
      void   init();
      void   clear();
      int    copy( const DeviceInfo * instance );

      int  marshal_cdr( CDX_XcdrEncoder_t *cdr, int just_keys) const ;
      int  marshal_key_hash( CDX_XcdrEncoder_t * cdr ) const;
      int  unmarshal_cdr( CDX_XcdrDecoder_t * cdr, int just_keys);
      int  unmarshal_key_hash( CDX_XcdrDecoder_t * cdr );
      // deprecated api:
      int  get_marshal_size( int offset, int just_keys ) const;
      int  marshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys) const ;
      int  unmarshal_cdr( unsigned char * buf, int offset, int stream_len, unsigned char swap, int just_keys);

      static void * alloc() { return new DeviceInfo; }
      static int    marshal_cdr( const void * instance, CDX_XcdrEncoder_t *cdr, int just_keys) 
                         { return ((DeviceInfo*)instance)->marshal_cdr( cdr, just_keys ); }
      static int    marshal_key_hash( const void * instance, CDX_XcdrEncoder_t *cdr) 
                         { return ((DeviceInfo*)instance)->marshal_key_hash( cdr ); }
      static int    unmarshal_cdr( void * instance, CDX_XcdrDecoder_t * cdr, int just_keys) 
                         { return ((DeviceInfo*)instance)->unmarshal_cdr( cdr, just_keys ); }
      static int    unmarshal_key_hash( void * instance, CDX_XcdrDecoder_t * cdr) 
                         { return ((DeviceInfo*)instance)->unmarshal_key_hash( cdr ); }

      static void      gen_typeid_v2 ( unsigned char * buf, int * buf_len );
      static int       gen_typeobj_v2 ( unsigned char * buf, int * buf_len );

      static unsigned char get_field_def(const char  * fieldname, 
                                         CoreDX_FieldDef_t * field_def);
    protected:
      std::string  _DeviceId;    /* ID: 0x00000000 */    /* key */
      std::string  _role;    /* ID: 0x00000001 */
      std::string  _sysName;    /* ID: 0x00000002 */
      std::string  _displayName;    /* ID: 0x00000003 */
      dds::core::optional<  struct ClockInfo >  _clockInfo;    /* ID: 0x00000004 */
      dds::core::optional<  struct ButtonInfo >  _buttonInfo;    /* ID: 0x00000005 */

    public:
      const std::string & DeviceId( ) const { return _DeviceId; }
            std::string & DeviceId( )       { return _DeviceId; }
      void  DeviceId( const std::string &  __DeviceId ) {  _DeviceId = __DeviceId; }
      void  DeviceId( const std::string && __DeviceId ) {  _DeviceId = __DeviceId; }
      const std::string & role( ) const { return _role; }
            std::string & role( )       { return _role; }
      void  role( const std::string &  __role ) {  _role = __role; }
      void  role( const std::string && __role ) {  _role = __role; }
      const std::string & sysName( ) const { return _sysName; }
            std::string & sysName( )       { return _sysName; }
      void  sysName( const std::string &  __sysName ) {  _sysName = __sysName; }
      void  sysName( const std::string && __sysName ) {  _sysName = __sysName; }
      const std::string & displayName( ) const { return _displayName; }
            std::string & displayName( )       { return _displayName; }
      void  displayName( const std::string &  __displayName ) {  _displayName = __displayName; }
      void  displayName( const std::string && __displayName ) {  _displayName = __displayName; }
      const dds::core::optional<struct ClockInfo> & clockInfo( ) const { return _clockInfo; }
            dds::core::optional<struct ClockInfo> & clockInfo( )       { return _clockInfo; }
      void  clockInfo( const dds::core::optional<struct ClockInfo> & __clockInfo ) {  _clockInfo = __clockInfo; }
      const dds::core::optional<struct ButtonInfo> & buttonInfo( ) const { return _buttonInfo; }
            dds::core::optional<struct ButtonInfo> & buttonInfo( )       { return _buttonInfo; }
      void  buttonInfo( const dds::core::optional<struct ButtonInfo> & __buttonInfo ) {  _buttonInfo = __buttonInfo; }

      typedef dds::sub::DataReader<DeviceInfo>  DataReader;
      typedef dds::pub::DataWriter<DeviceInfo>  DataWriter;

    private:

  }; //DeviceInfo
  typedef dds::sub::DataReader<DeviceInfo>  DeviceInfoDataReader;
  typedef dds::pub::DataWriter<DeviceInfo>  DeviceInfoDataWriter;


#include <dds/topic/TopicTraits.hpp>
#include <org/toc/coredx/topic/TopicTraits.hpp>
inline std::ostream & operator<< (std::ostream &out, ClockInfo const& data ) {
  (void)data;
  out << "topicName: ";
  out << "\"" << data.topicName() << "\"";
  out << std::endl;
  out << "digits: ";
  out <<  data.digits();
  out << std::endl;
  out << "hasGears: ";
  out <<  data.hasGears();
  out << std::endl;
  return out;
}
// ClockInfo support 
CDX_TOPIC_TRAITS( ClockInfo );
REGISTER_TOPIC_TYPE( ClockInfo );

inline std::ostream & operator<< (std::ostream &out, ButtonInfo const& data ) {
  (void)data;
  out << "topicName: ";
  out << "\"" << data.topicName() << "\"";
  out << std::endl;
  out << "color: ";
  out <<  data.color();
  out << std::endl;
  return out;
}
// ButtonInfo support 
CDX_TOPIC_TRAITS( ButtonInfo );
REGISTER_TOPIC_TYPE( ButtonInfo );

inline std::ostream & operator<< (std::ostream &out, DeviceInfo const& data ) {
  (void)data;
  out << "DeviceId: ";
  out << "\"" << data.DeviceId() << "\"";
  out << std::endl;
  out << "role: ";
  out << "\"" << data.role() << "\"";
  out << std::endl;
  out << "sysName: ";
  out << "\"" << data.sysName() << "\"";
  out << std::endl;
  out << "displayName: ";
  out << "\"" << data.displayName() << "\"";
  out << std::endl;
  out << "clockInfo: ";
  if (data.clockInfo()) {
  out << std::endl << "/----------------------------" << std::endl;
  out << (*data.clockInfo());
  out << "\\----------------------------" << std::endl;
  } else
    out << "NULL";
  out << std::endl;
  out << "buttonInfo: ";
  if (data.buttonInfo()) {
  out << std::endl << "/----------------------------" << std::endl;
  out << (*data.buttonInfo());
  out << "\\----------------------------" << std::endl;
  } else
    out << "NULL";
  out << std::endl;
  return out;
}
// DeviceInfo support 
CDX_TOPIC_TRAITS( DeviceInfo );
REGISTER_TOPIC_TYPE( DeviceInfo );


#ifdef _MSC_VER
#  pragma warning(pop)
#endif
#endif
